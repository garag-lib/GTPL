{"version":3,"file":"gtpl.min.js","mappings":"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","sources":["webpack://gtpl/webpack/universalModuleDefinition","webpack://gtpl/webpack/bootstrap","webpack://gtpl/webpack/runtime/define property getters","webpack://gtpl/webpack/runtime/global","webpack://gtpl/webpack/runtime/hasOwnProperty shorthand","webpack://gtpl/./src/GUtils.ts","webpack://gtpl/./src/GProxy.ts","webpack://gtpl/./src/global.js","webpack://gtpl/./src/GGenerator.ts","webpack://gtpl/./src/GTpl.ts","webpack://gtpl/./src/compiler/GParse.ts","webpack://gtpl/./src/compiler/GCode.ts","webpack://gtpl/./src/lib/gtpl.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gtpl\"] = factory();\n\telse\n\t\troot[\"gtpl\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\nexport function css2obj(css: string): Record<string, string> {\n    const obj: Record<string, string> = {};\n    const s = css.toLowerCase()\n        .replace(/-(.)/g, (m, g) => g.toUpperCase())\n        .replace(/;\\s?$/g, \"\")\n        .split(/:|;/g);\n    for (let i = 0, n = s.length; i < n; i += 2) {\n        obj[s[i].replace(/\\s/g, \"\")] = s[i + 1].replace(/^\\s+|\\s+$/g, \"\");\n    }\n    return obj;\n}\n\nexport function style2css(prop: any) {\n    return prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLocaleLowerCase();\n}\n\nconst typeArray = ['symbol', 'bigint', 'undefined', 'boolean', 'string', 'number'];\n\nexport function isStaticType(val: any): boolean {\n    if (val === null || val === undefined)\n        return true;\n    const type = typeof val;\n    return typeArray.includes(type);\n}\n\nfunction logArray(array: any[], level: number = 0): void {\n    const prefix = '  '.repeat(level); // Indentation for nested arrays\n    console.log(`${prefix}Array [`);\n    array.forEach(item => {\n        if (Array.isArray(item)) {\n            logArray(item, level + 1);\n        } else if (typeof item === 'object' && item !== null) {\n            logObject(item, level + 1);\n        } else {\n            console.log(`${prefix}  ${item}`);\n        }\n    });\n    console.log(`${prefix}]`);\n}\n\nfunction logObject(obj: any, level: number = 0): void {\n    const prefix = '  '.repeat(level); // Indentation for nested objects\n    console.log(`${prefix}{`);\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const value = obj[key];\n            if (Array.isArray(value)) {\n                console.log(`${prefix}  ${key}: `);\n                logArray(value, level + 1);\n            } else if (typeof value === 'object' && value !== null) {\n                console.log(`${prefix}  ${key}: `);\n                logObject(value, level + 1);\n            } else {\n                console.log(`${prefix}  ${key}: ${value}`);\n            }\n        }\n    }\n    console.log(`${prefix}}`);\n}\n\nexport function log(...args: any): void {\n    console.log('%c----------', 'font-weight:bold');\n    args.forEach((arg: any) => {\n        if (Array.isArray(arg)) {\n            logArray(arg);\n        } else if (typeof arg === 'object' && arg !== null) {\n            logObject(arg);\n        } else {\n            console.log(arg);\n        }\n    });\n    console.log('%c----------', 'font-weight:bold');\n}\n\nexport function STACK(...args: any) {\n    //const functionName = log.caller?.name || arguments.callee.caller?.name;\n    args.push((new Error(args.shift())).stack);\n    log(...args);\n}\n","import { TypeEventProxyHandler } from './GEnums';\nimport { isStaticType } from './GUtils';\n\nexport type PathProxyHandler = any;\nexport type EventFunctionProxyHandler = (\n  type: TypeEventProxyHandler,\n  path: PathProxyHandler,\n  value: any,\n  objRef: any\n) => void;\n\nexport const ISPROXY = Symbol('is proxy');\nexport const PROXYTARGET = Symbol('proxy target');\n\nfunction getProxyHandler(event: EventFunctionProxyHandler, ojRef: any, parent?: PathProxyHandler) {\n  const ProxyHandler = {\n    get: (target: any, prop: any, receiver: any): any => {\n      if (prop == ISPROXY)\n        return true;\n      if (prop == PROXYTARGET)\n        return target;\n      const ret = Reflect.get(target, prop, receiver);\n      if (isStaticType(ret)) {\n        return ret;\n      }\n      if (!(<any>ret)[ISPROXY]) {\n        return GProxy(ret, event, ojRef, [parent, prop]);\n      }\n      return ret;\n    },\n    set: (target: any, prop: any, value: any) => {\n      //const oldvalue: any = Reflect.get(target, prop);\n      if (!isStaticType(value))\n        while (value[ISPROXY]) value = value[PROXYTARGET];\n      const ret: any = Reflect.set(target, prop, value);\n      //if (Array.isArray(target)) {\n      //  if (!isNaN(prop))\n      event(TypeEventProxyHandler.SET, [parent, prop], value, ojRef);\n      //} else {\n      //  event(TypeEventProxyHandler.SET, [parent, prop], value, ojRef);\n      //}\n      return ret;\n    },\n    deleteProperty: (target: any, prop: any) => {\n      //console.log('deleteProperty');\n      //const oldvalue: any = Reflect.get(target, prop);\n      const ret = Reflect.deleteProperty(target, prop);\n      //const isarray = Array.isArray(target);\n      event(TypeEventProxyHandler.UNSET, [parent, prop], undefined, ojRef);\n      return ret;\n    }\n    //ownKeys\n    //has\n    //defineProperty\n    //getOwnPropertyDescriptor\n  };\n  return ProxyHandler;\n}\n\nexport function GProxy(target: any, event: EventFunctionProxyHandler, objRef: any, parent?: PathProxyHandler) {\n  return new Proxy(target, getProxyHandler(event, objRef, parent));\n}\n\nexport function pathToArray(path: PathProxyHandler, arr: any[] = []): any[] {\n  path.forEach(function (p: any) {\n    if (Array.isArray(p)) {\n      pathToArray(p, arr);\n    } else {\n      arr.push(p);\n    }\n  });\n  return arr;\n}\n\nexport function pathToString(path: PathProxyHandler, arr: any[] = []): String {\n  return pathToArray(path, arr).join('.');\n}\n\nexport function* iterPath(path: PathProxyHandler): any {\n  for (let i = 0, n = path.length; i < n; i++) {\n    const p = path[i];\n    if (Array.isArray(p))\n      yield* iterPath(p);\n    else yield p;\n  }\n}\n","//---\n\nlet temp = null;\n\nfunction check(it) {\n    return it && it.Math === Math && it;\n}\n\ntry {\n    temp =\n        check(typeof globalThis === 'object' && globalThis) ||\n        check(typeof window === 'object' && window) ||\n        check(typeof self === 'object' && self) ||\n        check(typeof global === 'object' && global) ||\n        (function () { return this; })() ||\n        Function('return this')();\n} catch (ex) {\n\n}\n\nexport const globalObject = temp;\n\n//---\n\nlet ptemp = null;\n\ntry {\n    const options = {\n        get passive() {\n            ptemp = true;\n            return false;\n        },\n    };\n    globalObject.addEventListener(\"test\", null, options);\n    globalObject.removeEventListener(\"test\", null, options);\n} catch (err) {\n    ptemp = false;\n}\n\nexport const passiveSupported = ptemp;\n\n//---","import { BindTypes, TypeEventProxyHandler } from './GEnums';\nimport { globalObject } from './global';\nexport interface IVarOrConst {\n    va?: null | TplVar,\n    ct?: null | string\n}\n\nexport interface IFunction {\n    name: TplVar,\n    params?: IVarOrConst[]\n}\n\nexport interface IIndex {\n    index: string,\n    target: string\n}\n\nexport interface IFormula {\n    code?: string,\n    vars?: TplVar[],\n    fnc?: Function\n}\n\nexport interface IObjParsed {\n    vorc?: IVarOrConst,\n    svar?: string,\n    functions?: IFunction[],\n    index?: IIndex,\n    formula?: IFormula,\n    params?: IVarOrConst[]\n}\n\nexport interface IGtplObject {\n    refresh(): unknown;\n    ID?: string,\n    Root: any,\n    Elements: any,\n    RenderElements?: any,\n    GtplChilds: Set<IGtplObject>,\n    BindMap: Map<IBindObject, IGtplObject>,\n    BindTree: any;\n    BindDef: any,\n    addBind: Function,\n    getContext: Function,\n    getValue: Function,\n    getRoot: Function,\n    getGtplRoot: Function,\n    destroy: Function,\n    eventPRoxy: Function,\n    addTo: Function,\n    launchChange: Function\n}\n\nexport interface IBindObject {\n    type: BindTypes,\n    prop?: string,\n    link: IObjParsed,\n    index?: number,\n    case?: IBindObject[],\n    gen?: ProGen,\n    uid?: string,\n    common?: any,\n    ele?: any,\n    mark?: any,\n    eles?: IGtplObject[],\n    gtpl?: IGtplObject,\n    simetric?: boolean,\n    attrs?: string[]\n}\n\n//---\n\nexport type AttrType = (string | IBindObject | string[]);\n\nexport type ProGen = string | Function;\n\nexport type TplVar = string[];\n\n//---\n\nfunction bindNode(bind: IBindObject, node?: Node, mark?: Node) {\n    if (mark)\n        bind.mark = mark;\n    if (node)\n        bind.ele = node;\n    return bind;\n}\n\nfunction appendChildsFromFnc(ele: Node | any[], childs: Node | Function | any[], objRoot: IGtplObject) {\n    //console.log('appendChildsFromFnc', ele, childs, objRoot);\n    if (Array.isArray(childs)) {\n        childs.forEach((child: any) => {\n            appendChildsFromFnc(ele, child, objRoot);\n        });\n    } else if (typeof childs == 'function') {\n        appendChildsFromFnc(ele, childs(objRoot), objRoot);\n    } else if (childs !== null && childs !== undefined) {\n        if (Array.isArray(ele)) {\n            ele.push(childs);\n        } else {\n            ele.appendChild(childs);\n            /*\n            try {\n                if (ele.nodeName && ele.nodeName.toLowerCase() == 'select' &&\n                    childs.nodeName && childs.nodeName.toLowerCase() == 'option') {\n                    if ((ele as HTMLSelectElement).value !== '' &&\n                        (ele as HTMLSelectElement).value === (childs as HTMLOptionElement).value) {\n                        (childs as HTMLOptionElement).selected = true;\n                    }\n                }\n            } catch (ex) { console.error(ex); }\n            */\n        }\n    }\n}\n\nfunction createElement(nodeName: string, attributes: AttrType[], fncChilds: Function, objRoot: IGtplObject) {\n    //console.log('createElement', nodeName, attributes, fncChilds, objRoot);\n    let tempvar: any = null;\n    switch (nodeName) {\n        case '#text':\n            if (tempvar == null)\n                tempvar = globalObject.document.createTextNode('');\n            if (typeof attributes == 'string')\n                tempvar.textContent = attributes;\n        case '#comment':\n            if (tempvar == null)\n                tempvar = globalObject.document.createComment('');\n            if (typeof attributes == 'string') {\n                tempvar.textContent = attributes;\n            } else {\n                attributes.forEach((attr) => {\n                    if (typeof attr == 'string') {\n                        tempvar.textContent = attr;\n                        return;\n                    }\n                    if (Array.isArray(attr)) {\n                        console.error(tempvar, attr);\n                        return;\n                    }\n                    if (attr.type == BindTypes.TEXT)\n                        objRoot.addBind(bindNode(<IBindObject>attr, tempvar));\n                    else objRoot.addBind(bindNode(<IBindObject>attr, undefined, tempvar));\n                });\n            }\n            return tempvar;\n        default:\n            const ele = globalObject.document.createElement(nodeName);\n            appendChildsFromFnc(ele, fncChilds, objRoot);\n            if (Array.isArray(attributes)) {\n                attributes.forEach((attr) => {\n                    if (Array.isArray(attr)) {\n                        ele.setAttribute(attr[0], attr[1]);\n                    } else {\n                        const bind: IBindObject = <IBindObject>attr;\n                        objRoot.addBind(bindNode(bind, ele));\n                    }\n                });\n            }\n            return ele;\n    }\n}\n\nfunction compile(gcode: string, ggenerator?: any): any {\n    return new Function('g', `return ${gcode};`)(ggenerator ? ggenerator : createElement);\n}\n\nexport const GGenerator = createElement;\n\nexport const GAddToo = appendChildsFromFnc;\n\nexport const GCompile = compile;","import { BindTypes, TypeEventProxyHandler } from \"./GEnums\";\nimport { IGtplObject, IBindObject, IIndex } from \"./GGenerator\";\nimport {\n  GProxy,\n  pathToArray,\n  PathProxyHandler,\n  PROXYTARGET,\n  ISPROXY,\n} from \"./GProxy\";\nimport { TplVar, GAddToo, IFunction, IVarOrConst } from \"./GGenerator\";\nimport { globalObject, passiveSupported } from \"./global\";\nimport { STACK, isStaticType, log } from \"./GUtils\";\n\nexport interface IBindDef {\n  key: string;\n  val: any;\n  pro: any;\n}\n\nconst globalCache: any = {\n  binitChangeEvents: false,\n};\n\n//---\nclass privateProperties {\n  private static globalVar = new WeakMap();\n\n  static init(gtpl: IGtplObject) {\n    if (!privateProperties.globalVar.has(gtpl)) {\n      privateProperties.globalVar.set(gtpl, {\n        GenerationFinish: false,\n        MarkEle: new WeakMap(),\n        memValues: new WeakMap(),\n        renderElements: new Set(),\n      });\n    }\n  }\n\n  static getProperty(gtpl: IGtplObject, key: string) {\n    privateProperties.init(gtpl);\n    const obj = privateProperties.globalVar.get(gtpl);\n    return obj[key];\n  }\n\n  static setProperty(gtpl: IGtplObject, key: string, value: any) {\n    privateProperties.init(gtpl);\n    const obj = privateProperties.globalVar.get(gtpl);\n    obj[key] = value;\n  }\n}\n\n//---\n\ninterface IsimetricAttrValue {\n  va: Array<string>;\n  ctx: IGtplObject;\n}\n\ntype simetricAttrValueSet = Set<IsimetricAttrValue>;\n\nconst simetricAttr: WeakMap<Node, simetricAttrValueSet> = new WeakMap();\n\nfunction initChangeEvents() {\n  if (globalCache.binitChangeEvents) {\n    return;\n  }\n  try {\n    globalCache.binitChangeEvents = true;\n    const changeEvent = function (event: any) {\n      const ele: any = event.target;\n      if (simetricAttr.has(ele)) {\n        const temp = simetricAttr.get(ele);\n        if (temp) {\n          for (let obj of temp) {\n            //console.log('event', event, obj, ele);\n            updateVar(obj.va, obj.ctx, ele.value);\n          }\n        }\n      }\n    };\n    if (globalObject.addEventListener) {\n      globalObject.addEventListener(\"input\", changeEvent);\n      globalObject.addEventListener(\"change\", changeEvent);\n    }\n  } catch (ex: any) {\n    STACK(ex.message);\n  }\n}\n\n//---\n\nfunction addCheckRenderElement(gtpl: IGtplObject, bind: IBindObject) {\n  const re: Set<IBindObject> = privateProperties.getProperty(\n    gtpl,\n    \"renderElements\"\n  );\n  if (!re.has(bind)) {\n    re.add(bind);\n  }\n}\n\nfunction checkRenderElements(gtpl: IGtplObject, originalbind: IBindObject) {\n  const re: Set<IBindObject> = privateProperties.getProperty(\n    gtpl,\n    \"renderElements\"\n  );\n  if (!re.has(originalbind)) {\n    return;\n  }\n  const arr = Array.isArray(gtpl.Elements) ? gtpl.Elements : [gtpl.Elements];\n  arr.forEach((ele: Node, index: number) => {\n    const bind: IBindObject = gtpl.RenderElements[index];\n    if (bind && re.has(bind)) {\n      let allok = true;\n      if (bind.ele) {\n        const element = Array.isArray(bind.ele) ? bind.ele[0] : bind.ele;\n        if (!bind.mark.parentNode && !element.parentNode) {\n          allok = false;\n        } else if (bind.mark.parentNode && !element.parentNode) {\n          show(bind);\n          if (bind.eles) {\n            (<any>bind.eles)[0].refresh();\n            if ((<any>bind.eles)[0].refCase)\n              show((<any>bind.eles)[0].refCase);\n          }\n        }\n      } else if (bind.eles) {\n        if (bind.mark.parentNode) {\n          let marca: Node | null = null;\n          const render_arr: any = [];\n          bind.eles.forEach((gtpl: IGtplObject) => {\n            const temp: any = [];\n            gtpl.refresh();\n            gtpl.addTo(temp);\n            temp.forEach((ele: Node) => {\n              if (!ele.parentNode) {\n                render_arr.push(ele);\n              } else if (!marca) {\n                marca = ele;\n              }\n            });\n          });\n          if (render_arr.length) {\n            show(\n              {\n                type: bind.type,\n                link: bind.link,\n                ele: render_arr,\n                mark: marca ? marca : bind.mark,\n              },\n              false\n            );\n          }\n        } else {\n          allok = false;\n        }\n      }\n      if (allok) {\n        re.delete(bind);\n      }\n    }\n  });\n}\n\n//---\n\nfunction updateVar(\n  va: Array<string>,\n  ctx: IGtplObject,\n  value: any,\n  force: boolean = false\n) {\n  //console.log('updateVar', va, value, force);\n  if (va.length > 1) {\n    const reduce: any = (obj: any, index: number, fin: number) => {\n      if (index == fin) return obj[va[index]];\n      return reduce(obj[va[index]], ++index, fin);\n    };\n    const ret = reduce(ctx.Root, 0, va.length - 2);\n    const fin = va[va.length - 1];\n    if (force || ret[fin] != value) {\n      ret[fin] = value;\n    }\n  } else {\n    const fin = va[0];\n    if (force || ctx.Root[fin] != value) {\n      ctx.Root[fin] = value;\n    }\n  }\n}\n\nfunction reduceVar(\n  gtpl: IGtplObject,\n  name: string[],\n  val?: any,\n  index?: number,\n  limit?: number\n): any {\n  if (index == undefined) index = 0;\n  if (limit !== undefined && index >= name.length - limit) return val;\n  const result = val == undefined ? gtpl.getValue(name[index++]) : val[name[index++]];\n  if (limit !== undefined && index >= name.length - limit) return result;\n  if (index >= name.length) return result;\n  return reduceVar(gtpl, name, result, index);\n}\n\nasync function reduceFnc(\n  gtpl: IGtplObject,\n  functions: IFunction[],\n  index?: number,\n  initval?: any\n): Promise<any> {\n  if (index == undefined) index = 0;\n  const func = functions[index++];\n  const ctx = gtpl.getContext(func.name[0]);\n  const fnc: Function = reduceVar(ctx, func.name);\n  const arrval: any[] = [];\n  if (func.params) {\n    func.params.forEach((param: IVarOrConst) => {\n      if (param.ct != undefined) arrval.push(param.ct);\n      else if (param.va != undefined) arrval.push(reduceVar(gtpl, param.va));\n    });\n  }\n  if (initval != undefined) arrval.push(initval);\n  try {\n    initval = await fnc.apply(ctx.Root, arrval);\n  } catch (ex: any) {\n    STACK(ex.message, fnc);\n    initval = undefined;\n  }\n  if (index >= functions.length) return initval;\n  return await reduceFnc(gtpl, functions, index, initval);\n}\n\n//---\n\nasync function calculateBind(me: IGtplObject, bind: IBindObject, value?: any, extraarguments?: any) {\n  let result: any = undefined;\n  const gtpl = bind.gtpl ? bind.gtpl : me;\n  if (bind.link.formula && bind.link.formula.fnc) {\n    const fnc: Function = bind.link.formula.fnc;\n    const arrval: any[] = [];\n    if (bind.link.formula.vars) {\n      const vars: TplVar[] = bind.link.formula.vars;\n      vars.forEach((key) => {\n        arrval.push(gtpl.getValue(key[0]));\n      });\n    }\n    if (extraarguments) {\n      arrval.push(extraarguments);\n    }\n    try {\n      //console.log(fnc, gtpl.Root, arrval);\n      result = await fnc.apply(gtpl.Root, arrval);\n    } catch (ex: any) {\n      STACK(ex.message, fnc);\n      result = undefined;\n    }\n  } else {\n    if (bind.link.vorc) {\n      if (bind.link.vorc.va != undefined)\n        result = value != undefined ? value : reduceVar(gtpl, bind.link.vorc.va);\n      if (bind.link.vorc.ct != undefined) result = bind.link.vorc.ct;\n    }\n    if (bind.link.functions) {\n      result = await reduceFnc(gtpl, bind.link.functions, 0, result);\n    }\n  }\n  return result;\n}\n\n//---\n\nfunction getContext(gtpl: IGtplObject, bind: IBindObject) {\n  let ctx: IGtplObject = gtpl;\n  if (bind.link.vorc && bind.link.vorc.va) {\n    ctx = gtpl.getContext(bind.link.vorc.va[0]);\n  } else if (bind.link.functions) {\n    const fnc: IFunction = bind.link.functions[0];\n    ctx = gtpl.getContext(fnc.name[0]);\n  }\n  return ctx;\n}\n\n//---\n\nfunction createGetterAndSetter(\n  gtpl: IGtplObject,\n  va: TplVar,\n  bind: IBindObject\n) {\n  const key = va[0];\n  const ref = gtpl.BindTree[key];\n  if (ref != undefined) {\n    return;\n  }\n  const defaultvalue = gtpl.getValue(key);\n  const objdef: IBindDef = {\n    key: key,\n    val: defaultvalue, // target\n    pro: undefined, // proxy\n  };\n  gtpl.BindDef.add(objdef);\n  try {\n    if (!gtpl.Root.hasOwnProperty(key))\n      gtpl.Root[key] = null;\n    Object.defineProperty(gtpl.Root, key, {\n      get: function () {\n        if (objdef.pro !== undefined) return objdef.pro;\n        if (isStaticType(objdef.val)) return objdef.val;\n        while (objdef.val[ISPROXY]) objdef.val = objdef.val[PROXYTARGET];\n        objdef.pro = GProxy(objdef.val, gtpl.eventPRoxy.bind(gtpl), objdef, [\n          objdef.key,\n        ]);\n        return objdef.pro;\n      },\n      set: function (newval: any) {\n        objdef.val = newval;\n        if (isStaticType(newval)) {\n          delete objdef.pro;\n          gtpl.eventPRoxy(\n            TypeEventProxyHandler.SET,\n            [objdef.key],\n            newval,\n            objdef\n          );\n          return objdef.val;\n        } else {\n          while (objdef.val[ISPROXY]) objdef.val = objdef.val[PROXYTARGET];\n          objdef.pro = GProxy(\n            objdef.val,\n            gtpl.eventPRoxy.bind(gtpl),\n            objdef,\n            [objdef.key]\n          );\n          gtpl.eventPRoxy(\n            TypeEventProxyHandler.SET,\n            [objdef.key],\n            newval,\n            objdef\n          );\n          return objdef.pro;\n        }\n      },\n    });\n  } catch (ex) {\n    STACK((<any>ex).message, key, gtpl.Root);\n  }\n}\n\nfunction addBind2Object(gtpl: IGtplObject, va: TplVar, bind: IBindObject) {\n  let ref: any = gtpl.BindTree;\n  for (let i = 0, n = va.length; i < n; i++) {\n    const name = va[i];\n    if (i == 0) {\n      const ctx = gtpl.getContext(name);\n      createGetterAndSetter(ctx, va, bind);\n      if (ctx != gtpl) {\n        // si se aade el bind a otro contexto, hay que almacenar el contexto original\n        bind.gtpl = gtpl;\n        // almacenamos en el contexto original una referencia al contexto donde se almacena el bind\n        if (!gtpl.BindMap) gtpl.BindMap = new Map();\n        gtpl.BindMap.set(bind, ctx);\n        addBind2Object(ctx, va, bind);\n        return;\n      }\n    }\n    if (ref[name] == undefined)\n      ref[name] = {};\n    if (i < n - 1) {\n      ref = ref[name];\n      if (ref.tree == undefined) ref.tree = {};\n      ref = ref.tree;\n    } else {\n      ref = ref[name];\n    }\n  }\n  if (ref.me == undefined) {\n    ref.me = new Set();\n  }\n  ref.me.add(bind);\n}\n\nfunction getBind2Object(\n  gtpl: IGtplObject,\n  va: TplVar,\n  bind: IBindObject\n): Set<IBindObject> {\n  /*\n    if (bind.gtpl && bind.gtpl != gtpl) {\n        console.error('getBind2Object', 2);\n        const original_gtpl = bind.gtpl;\n        delete bind.gtpl;\n        return getBind2Object(original_gtpl, va, bind);\n    }\n    */\n  /*\n     if (gtpl.BindMap && gtpl.BindMap.has(bind)) {\n         console.error('getBind2Object', 1);\n         const ctx_gtpl = gtpl.BindMap.get(bind);\n         if (ctx_gtpl && ctx_gtpl != gtpl) {\n             gtpl.BindMap.delete(bind);\n             return getBind2Object(ctx_gtpl, va, bind);\n         }\n     }\n     */\n  let ref: any = gtpl.BindTree;\n  for (let i = 0, n = va.length; i < n; i++) {\n    const name = va[i];\n    if (i < n - 1) {\n      ref = ref[name];\n      ref = ref.tree;\n    } else {\n      ref = ref[name];\n    }\n  }\n  return ref.me;\n}\n\nfunction delBind(gtpl: IGtplObject, bind: IBindObject) {\n  if (bind.link.vorc && bind.link.vorc.va) {\n    getBind2Object(gtpl, bind.link.vorc.va, bind).delete(bind);\n  }\n  if (bind.link.formula?.vars) {\n    bind.link.formula.vars.forEach((va) => {\n      getBind2Object(gtpl, va, bind).delete(bind);\n    });\n  }\n}\n\nfunction searchBind(gtpl: IGtplObject, bind: IBindObject): boolean {\n  let encontrado = false;\n  if (bind.link.vorc && bind.link.vorc.va) {\n    if (getBind2Object(gtpl, bind.link.vorc.va, bind).has(bind))\n      encontrado = true;\n  }\n  if (bind.link.formula?.vars) {\n    bind.link.formula.vars.forEach((va) => {\n      if (getBind2Object(gtpl, va, bind).has(bind)) encontrado = true;\n    });\n  }\n  if (!encontrado) {\n    const re: Set<IBindObject> = privateProperties.getProperty(\n      gtpl,\n      \"renderElements\"\n    );\n    if (re.has(bind)) re.delete(bind);\n  }\n  return encontrado;\n}\n\n//---\n\nfunction checkBindVar(gtpl: IGtplObject, bind: IBindObject): boolean {\n  if (bind.type == BindTypes.VAR) {\n    //log('checkBindVar', gtpl, bind);\n    if (bind.link.svar && bind.link.vorc && bind.link.vorc.va) {\n      const temp = bind.link.vorc.va.join(\"\");\n      if (temp == \"this\") {\n        bind.ele[bind.link.svar] = gtpl.Root;\n      } else {\n        bind.ele[bind.link.svar] = reduceVar(gtpl, bind.link.vorc.va);\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction checkBindEvent(gtpl: IGtplObject, bind: IBindObject): boolean {\n  if (bind.type == BindTypes.EVENT && bind.prop) {\n    //log('checkBindEvent', gtpl, bind);\n    const ctx: IGtplObject = getContext(gtpl, bind);\n    const obj = { gtpl: ctx, bind: bind };\n    const options: any = { passive: false };\n    if (\n      [\"wheel\", \"mousewheel\", \"touchstart\", \"touchmove\"].indexOf(\n        bind.prop.toLowerCase()\n      ) >= 0\n    )\n      options.passive = true;\n    bind.ele.addEventListener(\n      bind.prop,\n      async function (event: any) {\n        const result = await calculateBind(obj.gtpl, obj.bind, undefined, event);\n        if (typeof result == \"function\") {\n          if (obj.bind.link.params) {\n            const arrval: any = [];\n            obj.bind.link.params.forEach((param) => {\n              if (param.ct != undefined) arrval.push(param.ct);\n              else if (param.va != undefined)\n                arrval.push(reduceVar(gtpl, param.va));\n            });\n            result.apply(obj.gtpl.Root, [event, ...arrval]);\n          } else {\n            result.apply(obj.gtpl.Root, [event]);\n          }\n        } else {\n          if (event.preventDefault)\n            event.preventDefault();\n        }\n      },\n      passiveSupported ? options : false\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkBindFormula(gtpl: IGtplObject, bind: IBindObject): boolean {\n  let result = false;\n  if (bind.link.formula && bind.link.formula.vars && bind.link.formula.vars.length) {\n    result = true;\n    bind.link.formula.vars.forEach((va) => {\n      addBind2Object(gtpl, va, bind);\n    });\n  }\n  return result;\n}\n\nfunction checkSimetricBind(gtpl: IGtplObject, bind: IBindObject) {\n  if (\n    bind.type == BindTypes.ATTR &&\n    bind.prop &&\n    bind.link &&\n    bind.link.vorc &&\n    bind.link.vorc.va\n  ) {\n    const { prop } = bind;\n    if (prop.startsWith('[') && prop.endsWith(']')) {\n      //---\n      initChangeEvents();\n      //---\n      bind.simetric = true;\n      bind.prop = prop.slice(1, - 1);\n      //---\n      const va = bind.link.vorc.va;\n      const ctx: any = gtpl.getContext(va[0]);\n      //---\n      if (bind.prop == \"value\") {\n        if (!simetricAttr.has(bind.ele)) simetricAttr.set(bind.ele, new Set());\n        simetricAttr.get(bind.ele)?.add({\n          va: va,\n          ctx: ctx,\n        });\n      }\n      //---\n      if (bind.prop in bind.ele.constructor.prototype) {\n        const original: any = Object.getOwnPropertyDescriptor(\n          bind.ele.constructor.prototype,\n          bind.prop\n        );\n        if (original) {\n          Object.defineProperty(bind.ele, bind.prop, {\n            get: function () {\n              //console.log('get', bind, this, original.get.call(this));\n              return original.get.call(this);\n            },\n            set: function (value) {\n              //console.log('set', bind, this, value);\n              if (\n                bind.prop == \"value\" &&\n                bind.ele.nodeName.toLowerCase() == \"select\"\n              ) {\n                const ret = original.set.call(this, value);\n                if (original.get.call(this) == value)\n                  updateVar(va, ctx, value);\n                else log(\"select value not valid\", value + ' not in options');\n                return ret;\n              } else {\n                updateVar(va, ctx, value);\n                return original.set.call(this, value);\n              }\n            },\n          });\n        } else {\n          log(\n            \"simetric attr error\",\n            bind.prop,\n            \" not in \",\n            bind.ele.constructor.prototype\n          );\n        }\n      } else {\n        log(\"simetric attr error\", bind.prop, \" in \", bind.ele);\n      }\n      //---\n    }\n  }\n}\n\nfunction checkBind(gtpl: IGtplObject, bind: IBindObject): boolean {\n  let result = false;\n  if (bind.link.vorc && bind.link.vorc.va) {\n    result = true;\n    checkSimetricBind(gtpl, bind);\n    addBind2Object(gtpl, bind.link.vorc.va, bind);\n  }\n  if (bind.link.functions) {\n    bind.link.functions.forEach((fnc: IFunction) => {\n      if (fnc.params) {\n        fnc.params.forEach((param: IVarOrConst) => {\n          if (param.va) {\n            result = true;\n            addBind2Object(gtpl, param.va, bind);\n          }\n        });\n      }\n    });\n  }\n  return result;\n}\n\n//---\n\nfunction removeElements(elements: any) {\n  if (Array.isArray(elements)) {\n    elements.forEach((element) => {\n      if (element.destroy)\n        element.destroy(true);\n      else removeElements(element);\n    });\n  } else {\n    if (elements.destroy)\n      elements.destroy(true);\n    else elements.parentNode?.removeChild(elements);\n  }\n}\n\n//---\n\nfunction iterBind(\n  btree: any,\n  type: TypeEventProxyHandler,\n  path: string[],\n  value?: any,\n  arr: any = []\n) {\n  if (btree) {\n    if (btree.me)\n      btree.me.forEach((bind: IBindObject) => {\n        arr.push([type, bind, path, !path.length ? value : undefined]);\n      });\n    if (btree.tree) {\n      const base = Array.isArray(path) ? path.shift() : undefined;\n      for (let i in btree.tree) {\n        if (base == undefined || base == i) {\n          iterBind(\n            btree.tree[i],\n            type,\n            path,\n            value != undefined ? (base == undefined ? value[i] : value) : undefined,\n            arr\n          );\n        }\n      }\n    }\n  }\n  return arr;\n}\n\n//---\n\nfunction checkMarkEle(gtpl: IGtplObject, bind: IBindObject, bresult: boolean) {\n  // si hay varios tipos de bindados a un mismo elemento, if + switch por ejemplo\n  // hay que hacer que solo se genere en una ocasin, y el otro coja los elementos\n  // generados por el que primero llegue.\n  if (bresult) {\n    const MarkEle = privateProperties.getProperty(gtpl, \"MarkEle\");\n    const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n    if (!bind.ele) {\n      if (bind.mark) {\n        if (bind.gen) {\n          if (MarkEle.has(bind.mark)) {\n            bind.ele = MarkEle.get(bind.mark);\n          } else {\n            bind.ele = (<Function>bind.gen)(bind.gtpl ? bind.gtpl : gtpl);\n            MarkEle.set(bind.mark, bind.ele);\n          }\n          delete bind.gen;\n        } else {\n          if (MarkEle.has(bind.mark)) {\n            bind.ele = MarkEle.get(bind.mark);\n            memValues.delete(bind);\n          }\n        }\n      }\n    } else if (MarkEle.has(bind.mark)) {\n      if (bind.ele != MarkEle.get(bind.mark)) {\n        bind.ele = MarkEle.get(bind.mark);\n        memValues.delete(bind);\n      }\n    }\n  }\n}\n\nfunction checkMarkRender(bind: IBindObject) {\n  let allok = true;\n  if (bind.mark.checks) {\n    for (let i in bind.mark.checks) {\n      if (!bind.mark.checks[i]) {\n        allok = false;\n        break;\n      }\n    }\n  }\n  return allok;\n}\n\n/*\nfunction checkValSelect(parentElement: HTMLElement, childElement: HTMLElement) {\n    try {\n        if (parentElement.nodeName && parentElement.nodeName.toLowerCase() == 'select' &&\n            childElement.nodeName && childElement.nodeName.toLowerCase() == 'option') {\n            console.log('checkValSelect', parentElement, childElement);\n            if ((parentElement as HTMLSelectElement).value !== '' &&\n                (parentElement as HTMLSelectElement).value === (childElement as HTMLOptionElement).value) {\n                (childElement as HTMLOptionElement).selected = true;\n            }\n        }\n    } catch (ex) { console.error(ex); }\n}\n*/\n\nfunction show(bind: IBindObject, remove: boolean = true) {\n  if (bind.ele) {\n    if (Array.isArray(bind.ele)) {\n      bind.ele.forEach((ele) => {\n        bind.mark.parentNode.insertBefore(ele, bind.mark);\n        //checkValSelect(bind.mark.parentNode, ele);\n      });\n    } else {\n      bind.mark.parentNode.insertBefore(bind.ele, bind.mark);\n      //checkValSelect(bind.mark.parentNode, bind.ele);\n    }\n    if (remove) bind.mark.remove();\n  }\n}\n\nfunction hide(bind: IBindObject, insert: boolean = true) {\n  if (bind.ele) {\n    if (Array.isArray(bind.ele)) {\n      if (insert) bind.ele[0].parentNode.insertBefore(bind.mark, bind.ele[0]);\n      bind.ele.forEach((ele) => {\n        ele.remove();\n      });\n    } else {\n      if (insert) bind.ele.parentNode.insertBefore(bind.mark, bind.ele);\n      bind.ele.remove();\n    }\n  }\n}\n\nfunction renderBind(gtpl: IGtplObject, bind: IBindObject, render: boolean) {\n  const index = getElementIndex(gtpl, bind);\n  const canrender = checkMarkRender(bind);\n  if (render && canrender) {\n    if (index >= 0) gtpl.RenderElements[index] = bind;\n    if (bind.mark.parentNode) show(bind);\n    else if (index >= 0 && searchBind(gtpl, bind))\n      addCheckRenderElement(gtpl, bind);\n  } else {\n    if (index >= 0) delete gtpl.RenderElements[index];\n    if (bind.ele.parentNode) hide(bind);\n    else if (index >= 0 && searchBind(gtpl, bind))\n      addCheckRenderElement(gtpl, bind);\n  }\n  if (render && !canrender) return false;\n  return true;\n}\n\nfunction getElementIndex(gtpl: IGtplObject, bind: IBindObject) {\n  // si la marca se encuentra en el array de elementos, quiere decir que su padre\n  // es el padre de la marca, si va ser un elemento del dom puede existir posibilidad\n  // de que el parentelement de la marca an no exista, en ese caso, tenemos el array\n  // renderelements donde pondremos los elementos a renderizar en el mismo nivel que su marca\n  const index = gtpl.Elements.indexOf(bind.mark);\n  if (index >= 0) {\n    if (!gtpl.RenderElements) {\n      //gtpl.RenderElements = Array(gtpl.Elements.length).fill(null);\n      gtpl.RenderElements = {};\n    }\n  }\n  return index;\n}\n\nfunction createGTpl(\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  objindex?: IIndex,\n  elementos?: IGtplObject[],\n  row?: any,\n  refresh?: boolean /*, objparent: any*/\n) {\n  const options: any = {\n    parent: bind.gtpl ? bind.gtpl : gtpl,\n    generator: bind.gen,\n  };\n  if (objindex && elementos && row) {\n    const obj: any = {};\n    obj[objindex.index] = elementos.length;\n    obj[objindex.target] = row;\n    //obj[SPARENT] = objparent;\n    options.context = [objindex.index, objindex.target];\n    options.root = obj;\n  }\n  if (refresh !== undefined) {\n    options.refresh = refresh;\n  }\n  return new GTpl(options);\n}\n\n//---\n\nasync function updateTEXTbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('TEXT', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (result !== undefined && result !== null) {\n    if (memValues.has(bind) && memValues.get(bind) == result) {\n      return gtpl;\n    }\n    memValues.set(bind, result);\n  }\n  //---\n  bind.ele.textContent = result;\n  //---\n  return gtpl;\n}\n\nasync function updateATTRbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  gtpl = getContext(gtpl, bind);\n  const updateProperty = (prop: string, value: any) => {\n    if (bind.ele[prop] !== undefined && bind.ele[prop] !== null) {\n      if (value === undefined || value === null) {\n        if (bind.ele[prop] !== \"\")\n          bind.ele[prop] = null;\n      } else if (bind.ele[prop] != value) {\n        try {\n          bind.ele[prop] = value;\n        } catch (ex) {\n          STACK((<any>ex).message, bind.ele, prop);\n        }\n      }\n    } else {\n      if (value === undefined || value === null) {\n        bind.ele.removeAttribute(prop);\n      } else if (bind.ele.getAttribute(prop) != value) {\n        bind.ele.setAttribute(prop, value);\n      }\n    }\n  };\n  if (bind.prop) {\n    updateProperty(bind.prop, result);\n  } else {\n    if (result === undefined || result === null) {\n      if (bind.attrs) {\n        bind.attrs.forEach((key) => {\n          updateProperty(key, null);\n        });\n        delete bind.attrs;\n      }\n    } else {\n      if (!bind.attrs)\n        bind.attrs = [];\n      const missing = bind.attrs.filter(key => !(key in result));\n      missing.forEach((key) => {\n        updateProperty(key, null);\n      });\n      bind.attrs.length = 0;\n      for (let key in result) {\n        bind.attrs.push(key);\n        updateProperty(key, result[key]);\n      }\n    }\n  }\n  return gtpl;\n}\n\nasync function updateINNERbind(type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  gtpl = getContext(gtpl, bind);\n  if (result !== undefined && bind.ele.innerHTML != result)\n    bind.ele.innerHTML = result;\n  return gtpl;\n}\n\nasync function updateSTYLEbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('STYLE', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) == result) return gtpl;\n  memValues.set(bind, result);\n  //---\n  if (bind.prop) {\n    bind.ele.style[bind.prop] = result;\n  }\n  //---\n  return gtpl;\n}\n\nasync function updateIFbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('IF/NOTIF', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const bresult = bind.type == BindTypes.NOTIF ? !result : !!result;\n  //---\n  if (!bind.mark.checks) bind.mark.checks = {};\n  bind.mark.checks[bind.type] = bresult;\n  //---\n  checkMarkEle(gtpl, bind, bresult);\n  //---\n  if (!bind.ele) {\n    return gtpl;\n  }\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) === bresult) return gtpl;\n  //---\n  if (renderBind(gtpl, bind, bresult)) memValues.set(bind, bresult);\n  //---\n  return gtpl;\n}\n\nasync function updateFORbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //console.log('FOR', type, bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  //if (!searchBind(gtpl, bind)) {\n  //    return;\n  //}\n  //---\n  if (!bind.eles) bind.eles = [];\n  //---\n  const elementos = bind.eles;\n  const objindex: IIndex = <IIndex>bind.link.index;\n  //---\n  const render_arr: any = [];\n  const delete_arr: any = [];\n  //---\n  const index: any = (Array.isArray(path) && path.length) ? path[0] : undefined;\n  //---\n  if (!isNaN(index)) {\n    const ppath: any = path;\n    if (type == TypeEventProxyHandler.SET) {\n      let update = false;\n      if (ppath.length > 1) {\n        update = true;\n      } else if (ppath.length == 1 && elementos.length == result.length) {\n        const newgtpl = elementos[index];\n        newgtpl.Root[objindex.target] = result[index];\n        return gtpl;\n      }\n      if (update) {\n        const newgtpl = elementos[index];\n        ppath.shift();\n        updateVar(\n          ppath,\n          <any>{ Root: newgtpl.Root[objindex.target] },\n          reduceVar(gtpl, ppath, result[index]),\n          true\n        );\n      } else {\n        const newgtpl = createGTpl(\n          gtpl,\n          bind,\n          objindex,\n          elementos,\n          result[index],\n          false\n        );\n        elementos.push(newgtpl);\n        render_arr.push([newgtpl, index]);\n      }\n    }\n    if (type == TypeEventProxyHandler.UNSET) {\n      if (ppath.length > 1) {\n        const newgtpl = elementos[index];\n        newgtpl.Root[objindex.target] = result[index];\n      } else {\n        const newgtpl: IGtplObject = elementos.splice(index, 1)[0];\n        delete_arr.push([newgtpl, index]);\n      }\n    }\n  } else if (result && result.length) {\n    if (index == 'length' && elementos.length == result.length)\n      return gtpl;\n    result.forEach((row: any, index: number) => {\n      if (index >= elementos.length) {\n        const newgtpl = createGTpl(\n          gtpl,\n          bind,\n          objindex,\n          elementos,\n          row,\n          false /*, result*/\n        );\n        elementos.push(newgtpl);\n        render_arr.push([newgtpl, index]);\n      } else {\n        const obj: any = elementos[index].Root;\n        obj[objindex.target] = row;\n      }\n    });\n    if (elementos.length > result.length) {\n      const gtpls = elementos.splice(\n        result.length,\n        elementos.length - result.length\n      );\n      gtpls.forEach((newgtpl, index: number) => {\n        delete_arr.push([newgtpl, index]);\n      });\n    }\n  } else if (elementos.length) {\n    elementos.forEach((newgtpl, index: number) => {\n      delete_arr.push([newgtpl, index]);\n    });\n    elementos.length = 0;\n  }\n  //---\n  if (delete_arr.length) {\n    delete_arr.forEach((rowinfo: any) => {\n      const [newgtpl, index] = rowinfo;\n      newgtpl.destroy();\n      gtpl.GtplChilds.delete(newgtpl);\n    });\n  }\n  //---\n  if (render_arr.length) {\n    //---\n    const renderindex = getElementIndex(gtpl, bind);\n    if (renderindex >= 0) {\n      if (!gtpl.RenderElements[renderindex]) {\n        gtpl.RenderElements[renderindex] = bind;\n      }\n    }\n    //---\n    const all: any = [];\n    render_arr.forEach((rowinfo: any) => {\n      const [newgtpl, index] = rowinfo;\n      newgtpl.addTo(all);\n      gtpl.GtplChilds.add(newgtpl);\n    });\n    //---\n    if (bind.mark.parentNode) {\n      //---\n      show(\n        {\n          type: bind.type,\n          link: bind.link,\n          ele: all,\n          mark: bind.mark,\n        },\n        false\n      );\n      //---\n      render_arr.forEach((rowinfo: any) => {\n        rowinfo[0].refresh();\n      });\n      //---\n    } else if (renderindex >= 0 && searchBind(gtpl, bind)) {\n      addCheckRenderElement(gtpl, bind);\n    }\n    //---\n  }\n  //---\n  return gtpl;\n}\n\nasync function updateSWITCHbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('SWITCH', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const bresult = result !== undefined && result !== null ? true : false;\n  //---\n  if (!bind.mark.checks) bind.mark.checks = {};\n  bind.mark.checks[bind.type] = bresult;\n  //---\n  checkMarkEle(gtpl, bind, bresult);\n  //---\n  if (!bind.mark.checks) bind.mark.checks = {};\n  bind.mark.checks[bind.type] = result == undefined ? false : true;\n  //---\n  if (!bind.ele) {\n    return gtpl;\n  }\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) === result) {\n    return gtpl;\n  }\n  memValues.set(bind, result);\n  //---\n  if (bind.case && bind.case.length) {\n    //---\n    if (bind.eles && bind.eles.length) {\n      bind.eles.forEach((gtplcase: IGtplObject) => {\n        hide((<any>gtplcase).refCase);\n        gtplcase.destroy();\n        gtpl.GtplChilds.delete(gtplcase);\n      });\n      delete bind.eles;\n    }\n    //---\n    if (!searchBind(gtpl, bind)) {\n      return gtpl;\n    }\n    //---\n    if (bresult) {\n      //---\n      if (!bind.case[0].mark) {\n        //---\n        const mcobj: any = {};\n        //---\n        for (let i = 0, n = bind.ele.childNodes.length; i < n; i++) {\n          const node = bind.ele.childNodes[i];\n          if (node.nodeType === 8) {\n            if (node.textContent.length == 6) {\n              mcobj[node.textContent] = node;\n            }\n          }\n        }\n        //---\n        for (let i = 0, n = bind.case.length; i < n; i++) {\n          const ca = bind.case[i];\n          if (!ca.mark && ca.uid) {\n            ca.mark = mcobj[ca.uid];\n          }\n        }\n        //---\n      }\n      //---\n      for (let i = 0, n = bind.case.length; i < n; i++) {\n        const ca = bind.case[i];\n        const valca = await calculateBind(gtpl, ca);\n        if (valca == result) {\n          const gtplcase = createGTpl(\n            gtpl,\n            ca,\n            undefined,\n            undefined,\n            undefined,\n            false\n          );\n          ca.ele = gtplcase.Elements;\n          ca.eles = [gtplcase];\n          (<any>gtplcase).refCase = ca;\n          gtpl.GtplChilds.add(gtplcase);\n          //console.error('GtplChilds', gtpl.GtplChilds.size);\n          bind.eles = ca.eles;\n          break;\n        }\n      }\n      //---\n    }\n    //---\n  }\n  //---\n  if (renderBind(gtpl, bind, bresult)) {\n    if (bresult) {\n      (<any>bind.eles)[0].refresh();\n      show((<any>bind.eles)[0].refCase);\n    }\n  }\n  //---\n  return gtpl;\n}\n\nasync function updateISbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('IS', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const bresult = result !== undefined && result !== null ? true : false;\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) == result) return gtpl;\n  memValues.set(bind, result);\n  //---\n  let check = false;\n  if (bind.eles) {\n    check = true;\n    bind.eles[0].destroy();\n    gtpl.GtplChilds.delete(bind.eles[0]);\n    delete bind.eles;\n  } else if (bind.ele) {\n    hide(bind);\n  }\n  //---\n  if (!bresult) return gtpl;\n  //---\n  if (check && !searchBind(gtpl, bind)) {\n    return gtpl;\n  }\n  //---\n  if (Array.isArray(result) || typeof result == \"function\") {\n    const newgtpl = createGTpl(gtpl, {\n      link: bind.link,\n      type: bind.type,\n      gtpl: bind.gtpl,\n      gen: result,\n    });\n    bind.eles = [newgtpl];\n    gtpl.GtplChilds.add(newgtpl);\n    bind.ele = newgtpl.Elements;\n  } else {\n    bind.ele = result;\n  }\n  //---\n  privateProperties.getProperty(gtpl, \"MarkEle\").set(bind.mark, bind.ele);\n  //---\n  renderBind(gtpl, bind, bresult);\n  //---\n  return gtpl;\n}\n\n//---\n\nexport class GTpl implements IGtplObject {\n  ID!: string;\n\n  /**\n   * Referencia a la funcin generadora.\n   */\n  FncElements!: Function | Array<any>;\n\n  /**\n   * Array de array de elementos html que forman la plantilla\n   */\n  Elements!: Node[];\n\n  /**\n   * Objeto indexado a los elementos dinamicos de ka plantillas, for, switch etc...\n   */\n  RenderElements!: any;\n\n  /**\n   * Es el arbol de objetos bindados siguiendo la misma ramificacin que en el arbol html.\n   */\n  BindTree!: any;\n\n  /**\n   * Son los objetos bindados con constantes, no dinmicos.\n   */\n  BindConst!: Set<IBindObject>;\n\n  /**\n   * Mapa de objetos bindados a plantillas diferentes a la original.\n   * Por ejemplo: cuando se tiene una plantilla dentro de otra plantilla.\n   */\n  BindMap!: Map<IBindObject, IGtplObject>;\n\n  /**\n   * Son las claves de primer nivel de objetos bindados a la plantilla.\n   */\n  BindDef!: Set<IBindDef>;\n\n  /**\n   * Plantillas hijas.\n   */\n  GtplChilds!: Set<IGtplObject>;\n\n  /**\n   * Plantilla padre.\n   */\n  Parent!: IGtplObject;\n\n  /**\n   * Utilizado para localizar el contexto de la variable que se solicita.\n   */\n  Context!: Set<String>;\n\n  /**\n   * Objeto referencia para aplicar a la plantilla.\n   */\n  Root: any;\n\n  constructor(options?: any) {\n    //log('constructor', this, options);\n    this.ID = Math.random().toString(16).slice(2);\n    this.BindTree = {};\n    this.BindConst = new Set();\n    this.BindDef = new Set();\n    this.GtplChilds = new Set();\n    this.loadOptions(options);\n  }\n\n  loadOptions(options?: any) {\n    if (options) {\n      this.Root = options.root;\n      if (options.parent) this.Parent = options.parent;\n      if (options.context) this.Context = new Set(options.context);\n      if (options.generator) {\n        this.FncElements = options.generator;\n        this.Elements = [];\n        GAddToo(this.Elements, this.FncElements, this);\n      }\n      privateProperties.setProperty(this, \"GenerationFinish\", true);\n      if (options.refresh === undefined || options.refresh === true)\n        this.refresh();\n    }\n  }\n\n  getValue(key: any): any {\n    const ref = this.Root;\n    if (ref) {\n      if (ref.hasOwnProperty(key)) return ref[key];\n      if (ref[key] !== undefined) return ref[key];\n    }\n    if (this.Parent) return this.Parent.getValue(key);\n    return undefined;\n  }\n\n  getGtplRoot(): GTpl {\n    if (this.Parent) return this.Parent.getGtplRoot();\n    return this;\n  }\n\n  getRoot(): any {\n    if (this.Parent) return this.Parent.getRoot();\n    return this.Root;\n  }\n\n  getContext(key: string): GTpl {\n    if (this.Context && this.Context.has(key)) return this;\n    if (this.Parent) return this.Parent.getContext(key);\n    return this.getGtplRoot();\n  }\n\n  addBind(bind: IBindObject) {\n    //log('addBind', this, bind);\n    if (!checkBindVar(this, bind))\n      if (!checkBindEvent(this, bind))\n        if (!checkBindFormula(this, bind))\n          if (!checkBind(this, bind))\n            this.BindConst.add(bind);\n    if (privateProperties.getProperty(this, \"GenerationFinish\")) {\n      this.launchChange(TypeEventProxyHandler.UKNOW3, bind);\n    }\n  }\n\n  destroy(elements = true) {\n    //---\n    const num = Array.isArray(this.Elements) ? this.Elements.length : 1;\n    //---\n    this.GtplChilds.forEach((gtpl) => {\n      gtpl.destroy(false);\n    });\n    //---\n    if (this.BindMap) {\n      for (let [bind, gtpl] of this.BindMap) {\n        delBind(gtpl, bind);\n      }\n    }\n    //---\n    if (elements) {\n      removeElements(this.Elements);\n      if (this.RenderElements) {\n        for (let index = 0; index < num; index++) {\n          if (this.RenderElements[index]) {\n            const bind: IBindObject = this.RenderElements[index];\n            if (bind.ele) {\n              removeElements(bind.ele);\n            } else if (bind.eles) {\n              removeElements(bind.eles);\n            }\n          }\n        }\n        delete this.RenderElements;\n      }\n    }\n    //---\n  }\n\n  refresh() {\n    for (let objdef of this.BindDef) {\n      this.eventPRoxy(TypeEventProxyHandler.UKNOW4, [], undefined, objdef);\n    }\n    if (this.BindMap) {\n      for (let [bind, gtpl] of this.BindMap) {\n        gtpl.launchChange(TypeEventProxyHandler.UKNOW5, bind);\n      }\n    }\n    if (this.BindConst) {\n      for (let bind of this.BindConst) {\n        this.launchChange(TypeEventProxyHandler.UKNOW6, bind);\n      }\n    }\n  }\n\n  addTo(ele: Node | any[]) {\n    //console.log('addTo', ele);\n    if (this.RenderElements) {\n      const render_arr: any = [];\n      const arr = Array.isArray(this.Elements)\n        ? this.Elements\n        : [this.Elements];\n      arr.forEach((ele: Node, index: number) => {\n        if (this.RenderElements[index]) {\n          const bind: IBindObject = this.RenderElements[index];\n          if (bind.ele) {\n            render_arr.push(bind.ele);\n          } else if (bind.eles) {\n            bind.eles.forEach((gtpl: IGtplObject) => gtpl.addTo(render_arr));\n            render_arr.push(bind.mark);\n          }\n        } else {\n          render_arr.push(ele);\n        }\n      });\n      GAddToo(ele, render_arr, this);\n    } else {\n      GAddToo(ele, this.Elements, this);\n    }\n  }\n\n  eventPRoxy(\n    type: TypeEventProxyHandler,\n    path: PathProxyHandler,\n    value: any,\n    objRef: any\n  ) {\n    //log('eventPRoxy', 'event:', type, 'path:', path, 'value:', value, 'objref:', objRef);\n    const pa = pathToArray(path);\n    pa?.shift();\n    iterBind(this.BindTree[objRef.key], type, pa, value).forEach((args: any) =>\n      this.launchChange.apply(this, args)\n    );\n  }\n\n  async launchChange(\n    type: TypeEventProxyHandler,\n    bind: IBindObject,\n    path?: string[],\n    value?: any\n  ) {\n    //log('launchChange' /*, type, bind, path, value*/ );\n    const result = await calculateBind(this, bind, value);\n    let gtpl: IGtplObject = this;\n    switch (bind.type) {\n      case BindTypes.TEXT:\n        gtpl = await updateTEXTbind(type, this, bind, result, path);\n        break;\n      case BindTypes.ATTR:\n        gtpl = await updateATTRbind(type, this, bind, result, path);\n        break;\n      case BindTypes.INNER:\n        gtpl = await updateINNERbind(type, this, bind, result, path);\n        break;\n      case BindTypes.STYLE:\n        gtpl = await updateSTYLEbind(type, this, bind, result, path);\n        break;\n      case BindTypes.IF:\n      case BindTypes.NOTIF:\n        gtpl = await updateIFbind(type, this, bind, result, path);\n        break;\n      case BindTypes.FOR:\n        gtpl = await updateFORbind(type, this, bind, result, path);\n        break;\n      case BindTypes.SWITCH:\n        gtpl = await updateSWITCHbind(type, this, bind, result, path);\n        break;\n      case BindTypes.IS:\n        gtpl = await updateISbind(type, this, bind, result, path);\n        break;\n    }\n    checkRenderElements(gtpl, bind);\n  }\n}\n","import { IVarOrConst, IFunction, IObjParsed } from '../GGenerator';\nimport { TplVar } from '../GGenerator';\nimport { globalObject } from '../global.js';\n\nconst palabrasReservadas = [\n    \"abstract\", \"await\", \"boolean\", \"break\", \"byte\", \"case\", \"catch\",\n    \"char\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\",\n    \"do\", \"double\", \"else\", \"enum\", \"export\", \"extends\", \"false\", \"final\",\n    \"finally\", \"float\", \"for\", \"function\", \"goto\", \"if\", \"implements\", \"import\",\n    \"in\", \"instanceof\", \"int\", \"interface\", \"let\", \"long\", \"native\", \"new\",\n    \"null\", \"package\", \"private\", \"protected\", \"public\", \"return\", \"short\",\n    \"static\", \"super\", \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n    \"transient\", \"true\", \"try\", \"typeof\", \"var\", \"void\", \"volatile\", \"while\",\n    \"with\", \"yield\", \"arguments\", \"await\", \"async\", \"eval\"\n];\n\nexport class GParse {\n\n    private s!: string;\n    private i!: number;\n    private l!: number;\n    private r!: (string | IObjParsed)[];\n    private arr_acepted!: number[];\n    private ln!: string | null;\n\n    constructor() {\n        this.setAceptedAN();\n    }\n\n    getResult(): (string | IObjParsed)[] {\n        return this.r;\n    }\n\n    getSingleResult(): IObjParsed {\n        let result: any = null;\n        if (this.r && this.r.length == 1)\n            result = this.r[0];\n        return result;\n    }\n\n    setString(str: string) {\n        this.s = str;\n        this.l = str.length;\n        this.i = 0;\n        this.r = [];\n    }\n\n    setAceptedAN(acepted: string = '_') {\n        this.arr_acepted = Array.from(acepted).map((c: string) => c.charCodeAt(0));\n    }\n\n    isAN(str: string, firstCanNumber: boolean = true) {\n        if (str == undefined)\n            return false;\n        let ok: boolean;\n        for (let i = 0, n = str.length, code = 0; i < n; i++) {\n            code = str.charCodeAt(i);\n            ok = (code > 64 && code < 91) || (code > 96 && code < 123) || this.arr_acepted.indexOf(code) >= 0;\n            if (firstCanNumber)\n                ok = ok || (code > 47 && code < 58);\n            if (ok)\n                continue;\n            return false\n        }\n        return true;\n    }\n\n    checkStart(): boolean {\n        return this.s[this.i] == '{' && this.s[this.i + 1] == '{';\n    }\n\n    checkEnd(): boolean {\n        return this.s[this.i] == '}' && this.s[this.i + 1] == '}';\n    }\n\n    next() {\n        this.i++;\n        if (this.i >= this.l)\n            return false;\n        return true;\n    }\n\n    nop(all: boolean = false, cstop: string | null = null): boolean {\n        let cnow: null | string = null;\n        this.ln = null;\n        while (true) {\n            cnow = this.s[this.i];\n            if (cstop === cnow)\n                return true;\n            let ok = (cnow == ' ' || cnow == '\\t' || cnow == '\\r' || cnow == '\\n');\n            if (!ok && all) {\n                ok = (cnow != '\"' && cnow != \"'\" && !this.isAN(cnow));\n                if (ok) {\n                    this.ln = cnow;\n                }\n            }\n            if (ok) {\n                if (!this.next())\n                    return false;\n                continue;\n            }\n            return true;\n        }\n    }\n\n    getVOrC(): null | IVarOrConst {\n        let cnow = this.s[this.i];\n        if (cnow == '\"' || cnow == \"'\") {\n            return { ct: this.getConst() };\n        } else if (this.isAN(cnow, false)) {\n            return { va: this.getVar() };\n        }\n        return null;\n    }\n\n    getVar(point: boolean = true): null | string[] {\n        let str = this.s[this.i], cnow: null | string = null, acepted: boolean;\n        while (true) {\n            if (!this.next())\n                return str != '' ? str.split('.') : null;\n            cnow = this.s[this.i];\n            acepted = this.isAN(cnow);\n            if (point && !acepted)\n                acepted = cnow == '.';\n            if (acepted) {\n                str += cnow;\n                continue;\n            } else {\n                return str.split('.');\n            }\n        };\n    }\n\n    getConst(): null | string {\n        const into = this.s[this.i];\n        if (!this.next())\n            return null;\n        let str = this.s[this.i];\n        if (str == into) {\n            str = '';\n            if (!this.next())\n                return null;\n            return str;\n        }\n        let cnow: null | string = null, clast: null | string = null;\n        while (true) {\n            if (!this.next())\n                return null;\n            cnow = this.s[this.i];\n            if (cnow == into && clast != '\\\\') {\n                if (!this.next())\n                    return null;\n                return str;\n            }\n            str += cnow;\n            clast = cnow;\n        }\n    }\n\n    check(): boolean {\n\n        let i = 0;\n        let temp = '';\n        let obj: IObjParsed;\n        let vorc: null | IVarOrConst;\n        let cnow: string;\n        let thereare: boolean = false;\n\n        while (true) {\n\n            if (this.checkStart()) {\n\n                thereare = true;\n\n                if (temp != '') {\n                    this.r.push(temp);\n                    temp = '';\n                }\n\n                obj = {};\n\n                this.i += 2;\n\n                i = this.i;\n\n                if (!this.nop())\n                    return false;\n\n                vorc = this.getVOrC();\n\n                if (vorc) {\n\n                    obj.vorc = vorc;\n\n                    cnow = this.s[this.i];\n\n                    if (cnow == undefined)\n                        break;\n\n                    while (true) {\n\n                        if (cnow == ':') {\n\n                            if (!this.next())\n                                return false;\n\n                            const fnc = this.getVar();\n\n                            if (fnc === null)\n                                return false;\n\n                            if (!obj.functions)\n                                obj.functions = [];\n\n                            const func: IFunction = { name: fnc };\n\n                            obj.functions.push(func);\n\n                            cnow = this.s[this.i];\n\n                            if (cnow == undefined)\n                                break;\n\n                            if (cnow == '(') {\n\n                                if (!this.next())\n                                    return false;\n\n                                cnow = this.s[this.i];\n\n                                if (cnow == ')') {\n\n                                    if (!this.next())\n                                        return false;\n\n                                    cnow = this.s[this.i];\n\n                                    continue;\n                                }\n\n                                while (true) {\n\n                                    vorc = this.getVOrC();\n\n                                    if (!vorc)\n                                        return false;\n\n                                    cnow = this.s[this.i];\n\n                                    if (!func.params)\n                                        func.params = [];\n\n                                    func.params.push(vorc);\n\n                                    if (cnow == undefined)\n                                        break;\n\n                                    if (cnow == ',') {\n                                        if (!this.next())\n                                            return false;\n                                        cnow = this.s[this.i];\n                                        continue;\n                                    }\n\n                                    if (cnow == ')') {\n                                        if (!this.next())\n                                            return false;\n                                        cnow = this.s[this.i];\n                                        break;\n                                    }\n\n                                }\n\n                            }\n\n                        } else if (cnow == '#') {\n\n                            if (!this.next())\n                                return false;\n\n                            vorc = this.getVOrC();\n\n                            if (!vorc)\n                                return false;\n\n                            if (!obj.params)\n                                obj.params = [];\n\n                            obj.params.push(vorc);\n\n                            cnow = this.s[this.i];\n\n                        } else {\n\n                            break;\n\n                        }\n                    }\n\n                    if (cnow == ';') {\n\n                        if (!this.next())\n                            return false;\n\n                        const index = this.getVar(false);\n\n                        if (index === null)\n                            return false;\n\n                        cnow = this.s[this.i];\n\n                        if (cnow == ';') {\n\n                            if (!this.next())\n                                return false;\n\n                            const target = this.getVar(false);\n\n                            if (target === null)\n                                return false;\n\n                            obj.index = { index: index.join(''), target: target.join('') };\n\n                        } else {\n\n                            return false;\n\n                        }\n\n                    }\n\n                    if (!this.nop())\n                        return false;\n\n                    if (this.checkEnd()) {\n\n                        this.i++;\n\n                        this.r.push(obj);\n\n                    } else {\n\n                        if (!this.searchFormula(i))\n                            return false;\n\n                    }\n\n                } else {\n\n                    if (!this.searchFormula(i))\n                        return false;\n\n                }\n\n            } else {\n\n                temp += this.s[this.i];\n\n            }\n\n            if (!this.next())\n                break;\n\n        }\n\n        if (temp != '')\n            this.r.push(temp);\n\n        return thereare;\n\n    }\n\n    searchFormula(i: number): boolean {\n\n        let temp = this.s.substring(i, this.i);\n\n        while (true) {\n\n            if (this.checkEnd()) {\n\n                this.i++;\n\n                this.r.push({ formula: { code: temp, vars: this.findVars(temp) } });\n\n                temp = '';\n\n                break;\n\n            } else {\n\n                temp += this.s[this.i];\n\n                if (!this.next())\n                    return false;\n\n            }\n\n        }\n\n        return true;\n    }\n\n    findVars(str: string): TplVar[] {\n        const s = this.s;\n        const l = this.l;\n        const i = this.i;\n        this.s = str;\n        this.l = str.length;\n        this.i = 0;\n        let arr: TplVar[] = [], ret: null | IVarOrConst = null;\n        let ignoreall: boolean = false;\n        let cstop: string[] = [];\n        let ignore: any = [[]];\n        let declares = ['const', 'var', 'let'];\n        let arrowIndex: null | number = null;\n        while (true) {\n            let cs = cstop.length ? cstop[cstop.length - 1] : null;\n            if (arrowIndex !== null) {\n                if (cs == '}' || cs === null) {\n                    cs = '>';\n                } else {\n                    arrowIndex = null;\n                }\n            }\n            if (!this.nop(true, cs))\n                break;\n            if (cs !== null) {\n                let current = this.s[this.i];\n                if (current == '>') {\n                    if (!this.next())\n                        break;\n                    if (this.ln == '=' && arrowIndex !== null) {\n                        ignore.push(arr.splice(arrowIndex).map(v => v[0]));\n                        if (!this.nop(true, '{'))\n                            break;\n                        current = this.s[this.i];\n                        if (current == '{') {\n                            cstop.push('}');\n                        } else {\n                            ignore.pop();\n                        }\n                    }\n                    arrowIndex = null;\n                    continue;\n                }\n                if (current == '(') {\n                    //console.log('current', current, cstop.join());\n                    ignoreall = true;\n                    cstop.pop();\n                    cstop.push(')');\n                    if (!this.next())\n                        break;\n                    continue;\n                }\n                if (current == ')') {\n                    //console.log('current', current, cstop.join());\n                    ignoreall = false;\n                    cstop.pop();\n                    cstop.push('{');\n                    if (!this.next())\n                        break;\n                    continue;\n                }\n                if (current == '{') {\n                    //console.log('current', current, cstop.join());\n                    cstop.pop();\n                    cstop.push('}');\n                    if (!this.next())\n                        break;\n                    continue;\n                }\n                if (current == '}') {\n                    //console.log('current', current, cstop.join());\n                    cstop.pop();\n                    ignore.pop();\n                    //console.log('ignore pop', ignore[ignore.length - 1].join());\n                    if (!this.next())\n                        break;\n                    continue;\n                }\n            }\n            ret = this.getVOrC();\n            if (ret && ret.va) {\n                const va = ret.va;\n                if (palabrasReservadas.indexOf(va[0]) >= 0) {\n                    if (ret.va[0] == 'function') {\n                        //console.log('function');\n                        ignore.push([]);\n                        cstop.push('(');\n                    } else if (declares.includes(va[0])) {\n                        if (!this.nop(true))\n                            break;\n                        ret = this.getVOrC();\n                        if (ret && ret.va) {\n                            ignore[ignore.length - 1].push(ret.va[0]);\n                            //console.log('declare', va[0], ignore[ignore.length - 1].join());\n                        }\n                    }\n                    continue;\n                }\n                if (globalObject.hasOwnProperty(va[0]))\n                    continue;\n                if (this.ln == '.') {\n                    continue;\n                }\n                if (ignoreall) {\n                    ignore[ignore.length - 1].push(va[0]);\n                } else {\n                    if (ignore.length) {\n                        if (ignore.some((list: any) => list.includes(va[0]))) {\n                            continue;\n                        }\n                    }\n                    if (!arr.some(list => list[0] == va[0])) {\n                        if (this.ln == '(') {\n                            arrowIndex = arr.length;\n                        } else if (this.ln != ',' && arrowIndex !== null) {\n                            arrowIndex = null;\n                        }\n                        //console.log('valid', va);\n                        arr.push(va);\n                    }\n                }\n            } else if (!this.next()) {\n                break;\n            }\n        }\n        this.s = s;\n        this.i = i;\n        this.l = l;\n        return arr;\n    }\n\n}","import { NodeTypes, BindTypes } from '../GEnums';\nimport { GParse } from './GParse';\nimport { IBindObject, IFormula, IObjParsed } from '../GGenerator';\nimport { css2obj, log, style2css } from '../GUtils';\nimport { AttrType, ProGen } from '../GGenerator';\nimport { globalObject } from '../global';\n\nlet gparse!: GParse;\nlet gcont: number = 0;\nlet gcontchar: number = 0;\nconst regex_var = /([a-zA-Z\\_][\\w]+)\\s*\\=\\s*([a-zA-Z][\\w\\.]+)/gi;\n\nfunction getGen(nodeName: string, atributos: string | null, nodelist?: string | null): string {\n    return 'g(\\'' + nodeName + '\\',' + (atributos ? atributos : 'null') + ',' + (nodelist ? nodelist : 'null') + ',o)';\n}\n\nfunction getFunction(gen: string, parent?: any, commongen?: any): string {\n    if (commongen) {\n        let str: string[] = [];\n        commongen.forEach((com: any) => {\n            str.push('const ' + com.var + '=' + com.gen + ';');\n        });\n        return '((o)=>{' + str.join('') + 'return ' + gen + '})' + (!parent ? '(o)' : '');\n    }\n    return '((o)=>' + gen + ')' + (!parent ? '(o)' : '');\n}\n\nfunction addGen2Obj(bind: IBindObject, uuid: null | string, gen?: ProGen, plus?: string) {\n    let jsonBind: string = Attributes2JSON([bind], true);\n    jsonBind = jsonBind.substring(0, jsonBind.length - 1);\n    jsonBind = jsonBind + ',\"gen\":' + (gen ? gen : uuid) + (plus ? plus : '') + '}';\n    return jsonBind;\n}\n\nfunction addGen2ObjConditional(bind: IBindObject, uuid: string, bind_for: IBindObject | null, jsonAttr2: string, jsonAttr: string, plus?: string) {\n    bind.uid = uuid;\n    if (bind_for) {\n        if (jsonAttr2 != '')\n            jsonAttr2 += ',';\n        jsonAttr2 += addGen2Obj(bind, uuid, undefined, plus);\n    } else {\n        if (jsonAttr != '')\n            jsonAttr += ',';\n        jsonAttr += addGen2Obj(bind, uuid, undefined, plus);\n    }\n    return { jsonAttr2, jsonAttr };\n}\n\nfunction parseAttribute(atributos: AttrType[], prop: string, value: string): boolean {\n    let tt: null | BindTypes = null;\n    switch (prop) {\n        case 'g-is':\n            tt = tt || BindTypes.IS;\n        case 'g-binds':\n            tt = tt || BindTypes.ELES;\n        case 'g-bind':\n            tt = tt || BindTypes.ELE;\n        case 'g-attr':\n            tt = tt || BindTypes.ATTR;\n        case 'g-if':\n            tt = tt || BindTypes.IF;\n        case 'g-notif':\n            tt = tt || BindTypes.NOTIF;\n        case 'g-switch':\n            tt = tt || BindTypes.SWITCH;\n        case 'g-case':\n            tt = tt || BindTypes.CASE;\n        case 'g-for':\n            tt = tt || BindTypes.FOR;\n        case 'g-inner':\n            tt = tt || BindTypes.INNER;\n            gparse.setString(`{{${value}}}`);\n            if (gparse.check()) {\n                const attrObj = {\n                    type: tt,\n                    link: gparse.getSingleResult()\n                };\n                if (tt === BindTypes.IS) {\n                    atributos.unshift(attrObj);\n                } else {\n                    atributos.push(attrObj);\n                }\n                return true;\n            }\n            break;\n        case 'g-var':\n            tt = tt || BindTypes.VAR;\n            if (value.match(regex_var)) {\n                const vars = value.split(regex_var);\n                atributos.push({\n                    type: tt,\n                    link: {\n                        svar: vars[1],\n                        vorc: {\n                            va: vars[2].split('.')\n                        }\n                    }\n                });\n                return true;\n            }\n            break;\n        case 'g-tpl':\n            tt = tt || BindTypes.TPL;\n            atributos.push({\n                type: tt,\n                link: {\n                    vorc: {\n                        ct: value\n                    }\n                }\n            });\n            return true;\n        case 'style':\n            let csstext: string = '';\n            gparse.setString(value);\n            if (gparse.check()) {\n                let r: any = gparse.getResult();\n                if (r && r.length) {\n                    if (r.length == 1) {\n                        atributos.push({\n                            type: BindTypes.STYLE,\n                            prop: 'cssText',\n                            link: <any>r[0]\n                        });\n                        return true;\n                    }\n                    const cssobj = css2obj(value);\n                    for (const [key, val] of Object.entries(cssobj)) {\n                        gparse.setString(<string>val);\n                        if (gparse.check()) {\n                            r = gparse.getSingleResult();\n                            atributos.push({\n                                type: BindTypes.STYLE,\n                                prop: key,\n                                link: r\n                            });\n                        } else {\n                            csstext += csstext ? ';' : '';\n                            csstext += `${style2css(key)}:${val}`;\n                        }\n                    }\n                    if (csstext != '')\n                        atributos.push(['style', csstext]);\n                    return true;\n                }\n            }\n            break;\n        default:\n            gparse.setString(value);\n            if (gparse.check()) {\n                const r = gparse.getResult();\n                if (r && r.length == 1) {\n                    const attrObj = {\n                        type: prop.startsWith('on') ? BindTypes.EVENT : BindTypes.ATTR,\n                        prop: prop.startsWith('on') ? prop.substring(2) : prop,\n                        link: <any>r[0]\n                    };\n                    atributos.push(attrObj);\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\n\n/*\nfunction Attributes2JSON(atributos: AttrType[], onlyone: boolean = false): string {\n    const json: string[] = [];\n    atributos.forEach((attr: AttrType) => {\n        if (Array.isArray(attr) || typeof attr == 'string') {\n            json.push(JSON.stringify(attr));\n        } else {\n            const bind: IBindObject = <IBindObject>attr;\n            if (bind.link && bind.link.formula) {\n                const obj: string[] = [];\n                for (let i in bind) {\n                    const nivel1: any = (<any>bind)[i];\n                    if (obj.length)\n                        obj.push(',');\n                    if (i == 'link') {\n                        obj.push('\"link\":{');\n                        for (let ii in nivel1) {\n                            const nivel2 = nivel1[ii];\n                            if (obj[obj.length - 1] != '\"link\":{')\n                                obj.push(',');\n                            if (ii == 'formula') {\n                                obj.push('\"formula\":{');\n                                if (nivel2.vars)\n                                    obj.push('\"vars\":' + JSON.stringify(nivel2.vars) + ',');\n                                let isasync = '';\n                                if (nivel2.code.match(/[\\s\\;\\r\\n]await[\\W]/gm))\n                                    isasync = ' async ';\n                                if (nivel2.code.match(/[\\s\\;\\r\\n]return[\\W]/gm)) {\n                                    obj.push('\"fnc\":' + isasync + 'function(' +\n                                        (nivel2.vars ? (nivel2.vars.map((arr: any) => arr[0]).join(',')) : '') +\n                                        '){' +\n                                        nivel2.code +\n                                        '}');\n                                } else {\n                                    obj.push('\"fnc\":' + isasync + 'function(' +\n                                        (nivel2.vars ? (nivel2.vars.map((arr: any) => arr[0]).join(',')) : '') +\n                                        '){return(' +\n                                        nivel2.code +\n                                        ')}');\n                                }\n                                obj.push('}');\n                            } else {\n                                obj.push(JSON.stringify(ii) + ':' + JSON.stringify(nivel2));\n                            }\n                        }\n                        obj.push('}');\n                    } else {\n                        obj.push(JSON.stringify(i) + ':' + JSON.stringify(nivel1));\n                    }\n                }\n                json.push('{' + obj.join('') + '}');\n            } else {\n                json.push(JSON.stringify(attr));\n            }\n        }\n    });\n    if (onlyone)\n        return json.join(',');\n    return '[' + json.join(',') + ']';\n}\n*/\n\nfunction Attributes2JSON(atributos: AttrType[], onlyone: boolean = false): string {\n    const json = atributos.map(attr => {\n        if (Array.isArray(attr) || typeof attr === 'string') {\n            return JSON.stringify(attr);\n        } else {\n            const bind = attr as IBindObject;\n            if (bind.link?.formula) {\n                const obj = Object.entries(bind).map(([key, value]) => {\n                    if (key === 'link') {\n                        const linkObj = Object.entries(value).map(([subKey, subValue]) => {\n                            if (subKey === 'formula') {\n                                const { vars, code } = subValue as IFormula;\n                                if (code != undefined) {\n                                    const fncParams = vars?.map(v => v[0]).join(',') || '';\n                                    const isAsync = code.match(/[\\s;]await[\\W]/gm) ? ' async ' : '';\n                                    const fncBody = `{${code}}`;\n                                    return `\"${subKey}\":{\"vars\":${JSON.stringify(vars)},\"fnc\":${isAsync}function(${fncParams})${fncBody}}`;\n                                } else {\n                                    log('formula without code');\n                                }\n                            }\n                            return `\"${subKey}\":${JSON.stringify(subValue)}`;\n                        }).join(',');\n                        return `\"${key}\":{${linkObj}}`;\n                    }\n                    return `\"${key}\":${JSON.stringify(value)}`;\n                }).join(',');\n                return `{${obj}}`;\n            } else {\n                return JSON.stringify(attr);\n            }\n        }\n    });\n    return onlyone ? json.join(',') : `[${json.join(',')}]`;\n}\n\nfunction obtenerPrefijoChar(n: number) {\n    const letras = 'abcdefghijklmnopqrstuvwxyz';\n    let prefijo = '';\n    prefijo += letras[Math.floor(n / letras.length)];\n    prefijo += letras[n % letras.length];\n    return prefijo;\n}\n\nfunction getId() {\n    gcont++;\n    if (gcont > 9999) {\n        gcontchar = 1;\n        gcontchar++;\n    }\n    return obtenerPrefijoChar(gcontchar) + String(gcont).padStart(4, '0');\n}\n\nasync function NodeList2Function(nodes: NodeListOf<ChildNode> | Node[], parent?: any, headers?: boolean, bindSwitch?: null | IBindObject): Promise<string> {\n    //---\n    if (gparse == null)\n        gparse = new GParse();\n    //---\n    let parse: string = '';\n    if (headers !== false)\n        parse = '[';\n    //---\n    let bind_for: null | IBindObject,\n        bind_switch: null | IBindObject,\n        bind_case: null | IBindObject,\n        bind_if: null | IBindObject,\n        bind_is: null | IBindObject,\n        bind_tpl: null | IBindObject;\n    let ele: HTMLElement, real: undefined | HTMLElement | Node;\n    let childs: NodeListOf<ChildNode>;\n    let childsnodes: string,\n        jsonAttr: string,\n        jsonAttr2: string,\n        jsonBind: string,\n        attrs: string;\n    let atributos: AttrType[];\n    let uuid: string;\n    //---\n    for (var i = 0, fin = nodes.length; i < fin; i++) {\n        var node = nodes[i];\n        bind_for = bind_switch = bind_case = bind_if = bind_is = bind_tpl = null;\n        childsnodes = jsonAttr = jsonAttr2 = jsonBind = attrs = '';\n        switch (node.nodeType) {\n            case NodeTypes.ELEMENT_NODE:\n                {\n                    //---\n                    if (node.nodeName.toLowerCase() == 'script') {\n                        if (parse != '[')\n                            parse += ',';\n                        parse += getGen(node.nodeName, JSON.stringify(node.textContent));\n                        continue;\n                    }\n                    //---\n                    ele = <HTMLElement>node;\n                    atributos = [];\n                    for (let i = 0, n = ele.attributes.length, ref: NamedNodeMap = ele.attributes; i < n; i++) {\n                        const attr = ref.item(i);\n                        if (attr) {\n                            if (!parseAttribute(atributos, attr.name, attr.value)) {\n                                atributos.push([attr.name, attr.value]);\n                            } else if (atributos.length) {\n                                const bind: any = atributos[atributos.length - 1];\n                                if (bind) {\n                                    if (bind.type == BindTypes.IS) {\n                                        bind_is = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.IF || bind.type == BindTypes.NOTIF) {\n                                        bind_if = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.FOR) {\n                                        bind_for = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.SWITCH) {\n                                        bind_switch = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.CASE) {\n                                        if (!bindSwitch)\n                                            throw new Error('not switch');\n                                        if (!bindSwitch.case)\n                                            bindSwitch.case = [];\n                                        bindSwitch.case.push(bind);\n                                        bind_case = <IBindObject>bind;\n                                        bind_case.index = bindSwitch.case.length - 1;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.TPL) {\n                                        bind_tpl = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    //---\n                    if (bind_for && bind_case)\n                        throw new Error('not for and case ' + Array.from(ele.attributes, (item) => item.name + '=\"' + item.value + '\"').join(' '));\n                    if (bind_if && bind_case)\n                        throw new Error('not if and case ' + Array.from(ele.attributes, (item) => item.name + '=\"' + item.value + '\"').join(' '));\n                    if (bind_is && (bind_case || bind_switch || bind_tpl))\n                        throw new Error('not is and ( case or switch ot tpl ) ' + Array.from(ele.attributes, (item) => item.name + '=' + item.value + '\"').join(' '));\n                    //---\n                    if (parse != '[' && parse != '')\n                        parse += ',';\n                    //---\n                    if (bind_tpl) {\n                        const ct: any = (<any>bind_tpl).link.vorc.ct;\n                        const tpl = globalObject.document.getElementById(ct);\n                        if (tpl) {\n                            real = (ele.nodeName.toLowerCase() == 'template') ? parent : ele;\n                            childs = (tpl.nodeName.toLowerCase() == 'template') ? (<any>tpl).content.childNodes : [tpl];\n                            childsnodes = await NodeList2Function(childs, real, true, bind_switch);\n                        } else {\n                            /** @TODO better fetch **/\n                            const tpl = await (await fetch(ct)).text();\n                            const parser = new DOMParser();\n                            const doc = parser.parseFromString(tpl.trim(), \"text/html\");\n                            childsnodes = await NodeList2Function(doc.body.childNodes, real, true, bind_switch);\n                        }\n                    } else {\n                        real = (ele.nodeName.toLowerCase() == 'template') ? (<any>ele).content : ele;\n                        childs = (<any>real).childNodes;\n                        childsnodes = await NodeList2Function(childs, real, true, bind_switch);\n                    }\n                    //---\n                    if (bind_is || bind_if || bind_case || bind_for || bind_switch) {\n\n                        uuid = getId();\n\n                        jsonAttr = '';\n                        jsonAttr2 = '';\n\n                        const common: any = [];\n\n                        attrs = Attributes2JSON(atributos);\n\n                        if (bind_is) {\n                            ({ jsonAttr2, jsonAttr } = addGen2ObjConditional(bind_is, uuid, bind_for, jsonAttr2, jsonAttr));\n                        }\n\n                        if (bind_if) {\n                            ({ jsonAttr2, jsonAttr } = addGen2ObjConditional(bind_if, uuid, bind_for, jsonAttr2, jsonAttr));\n                        }\n\n                        if (bind_switch) {\n                            bind_switch.uid = uuid;\n                            const cases = bind_switch.case;\n                            delete bind_switch.case;\n                            //---\n                            jsonBind = '';\n                            if (cases) {\n                                cases.forEach((ccase: IBindObject) => {\n                                    if (ccase.common) {\n                                        ccase.common.forEach((com: any) => common.push(com));\n                                        delete ccase.common;\n                                    }\n                                    if (ccase.gen) {\n                                        const gen = ccase.gen;\n                                        delete ccase.gen;\n                                        if (jsonBind != '')\n                                            jsonBind += ',';\n                                        jsonBind += addGen2Obj(ccase, null, gen);\n                                    }\n                                });\n                            }\n                            //---\n                            ({ jsonAttr2, jsonAttr } = addGen2ObjConditional(bind_switch, uuid, bind_for, jsonAttr2, jsonAttr, ',\"case\":[' + jsonBind + ']'));\n                            //---\n                        }\n\n                        if (bind_tpl) {\n\n                            if (ele.nodeName.toLowerCase() == 'template') {\n\n                                common.push({\n                                    'var': uuid,\n                                    'gen': childsnodes\n                                });\n\n                            } else {\n\n                                common.push({\n                                    'var': uuid,\n                                    'gen': getFunction(getGen(ele.nodeName, attrs, childsnodes), true)\n                                });\n\n                            }\n\n                        } else {\n\n                            common.push({\n                                'var': uuid,\n                                'gen': bind_is ? 'null' : getFunction(getGen(ele.nodeName, attrs, childsnodes), true)\n                            });\n\n                        }\n\n                        if (bind_case) {\n\n                            bind_case.uid = uuid;\n                            bind_case.gen = uuid;\n                            bind_case.common = common;\n\n                            parse += getFunction(getGen('#comment', '[' + JSON.stringify(uuid) + ',' + jsonAttr + ']'), parent);\n\n                        } else {\n\n                            if (bind_for) {\n\n                                if (bind_if || bind_is || bind_switch) {\n\n                                    bind_for.uid = getId();\n                                    if (jsonAttr != '')\n                                        jsonAttr += ',';\n                                    jsonAttr += addGen2Obj(bind_for, bind_for.uid);\n\n                                    // jsonAttr2 -> solo if, notif, switch, is ...\n\n                                    common.push({\n                                        'var': bind_for.uid,\n                                        'gen': getFunction(getGen('#comment', '[' + JSON.stringify(uuid) + ',' + jsonAttr2 + ']'), true)\n                                    });\n\n                                } else {\n\n                                    bind_for.uid = uuid;\n                                    if (jsonAttr != '')\n                                        jsonAttr += ',';\n                                    jsonAttr += addGen2Obj(bind_for, uuid);\n\n                                }\n\n                                // jsonAttr -> solo for\n\n                                parse += getFunction(getGen('#comment', '[' + JSON.stringify(bind_for.uid) + ',' + jsonAttr + ']'), parent, common);\n\n                            } else {\n\n                                // jsonAttr -> solo if, notif, switch, is ...\n\n                                parse += getFunction(getGen('#comment', '[' + JSON.stringify(uuid) + ',' + jsonAttr + ']'), parent, common);\n\n                            }\n\n                        }\n\n                    } else {\n\n                        if (bind_tpl) {\n\n                            if (ele.nodeName.toLowerCase() == 'template') {\n\n                                parse += childsnodes;\n\n                            } else {\n\n                                parse += getFunction(getGen(ele.nodeName, Attributes2JSON(atributos), childsnodes), parent);\n\n                            }\n\n                        } else {\n\n                            parse += getFunction(getGen(ele.nodeName, Attributes2JSON(atributos), childsnodes), parent);\n\n                        }\n\n                    }\n                    //---\n                }\n                break;\n            case NodeTypes.TEXT_NODE:\n                {\n                    let normal: boolean = true;\n                    if (node.nodeValue) {\n                        gparse.setString(node.nodeValue);\n                        if (gparse.check()) {\n                            normal = false;\n                            const r = gparse.getResult();\n                            if (r && r.length) {\n                                r.forEach((item: string | IObjParsed) => {\n                                    if (parse != '[' && parse != '')\n                                        parse += ',';\n                                    if (typeof item == 'string') {\n                                        parse += getGen(node.nodeName, JSON.stringify(item));\n                                    } else {\n                                        parse += getGen(node.nodeName, Attributes2JSON([{\n                                            type: BindTypes.TEXT,\n                                            prop: 'textContent',\n                                            link: item\n                                        }]));\n                                    }\n                                });\n                            }\n                        }\n                    }\n                    if (normal) {\n                        if (parse != '[' && parse != '')\n                            parse += ',';\n                        parse += getGen(node.nodeName, JSON.stringify(node.nodeValue));\n                    }\n                }\n                break;\n            case NodeTypes.COMMENT_NODE:\n                {\n                    if (parse != '[' && parse != '')\n                        parse += ',';\n                    parse += getGen(node.nodeName, JSON.stringify(node.nodeValue));\n                }\n                break;\n        }\n    };\n    if (headers !== false)\n        parse += ']';\n    if (parent === undefined)\n        return '(o)=>' + parse;\n    return parse;\n}\n\nexport async function GCode(html: string | Node | NodeListOf<ChildNode>): Promise<string> {\n    if (typeof html == 'string') {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html.trim(), \"text/html\");\n        return NodeList2Function(doc.body.childNodes);\n    } else {\n        return NodeList2Function(html instanceof Node ? [html] : html);\n    }\n}","\nimport { GTpl } from \"../GTpl\";\nimport { GGenerator, GCompile, GAddToo } from \"../GGenerator\";\nimport { STACK, css2obj, style2css } from \"../GUtils\";\nimport { GCode } from \"../compiler/GCode\";\nimport { globalObject, passiveSupported } from \"../global\";\nimport { ISPROXY, PROXYTARGET } from \"../GProxy\";\n\nexport default {\n    'GTpl': GTpl,\n    'GGenerator': GGenerator,\n    'GAddToo': GAddToo,\n    'jit': {\n        'GCompile': GCompile,\n        'GCode': GCode\n    },\n    'utils': {\n        'stack': STACK,\n        'css2obj': css2obj,\n        'style2css': style2css,\n        'globalObject': globalObject,\n        'passiveSupported': passiveSupported,\n        'PROXYTARGET': PROXYTARGET,\n        'ISPROXY': ISPROXY\n    }\n};\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","css2obj","css","s","toLowerCase","replace","m","toUpperCase","split","i","n","length","style2css","toLocaleLowerCase","typeArray","isStaticType","val","type","includes","logArray","array","level","prefix","repeat","console","log","forEach","item","Array","isArray","logObject","value","args","arg","STACK","push","Error","shift","stack","ISPROXY","Symbol","PROXYTARGET","GProxy","target","event","objRef","parent","Proxy","ojRef","receiver","ret","Reflect","set","deleteProperty","undefined","getProxyHandler","pathToArray","path","arr","p","temp","check","it","Math","self","ex","globalObject","ptemp","options","passive","addEventListener","removeEventListener","err","passiveSupported","bindNode","bind","node","mark","ele","appendChildsFromFnc","childs","objRoot","child","appendChild","createElement","nodeName","attributes","fncChilds","tempvar","document","createTextNode","textContent","createComment","attr","error","addBind","setAttribute","GGenerator","GAddToo","globalCache","binitChangeEvents","privateProperties","static","WeakMap","init","gtpl","globalVar","has","GenerationFinish","MarkEle","memValues","renderElements","Set","getProperty","setProperty","simetricAttr","addCheckRenderElement","re","add","updateVar","va","ctx","force","reduce","index","fin","Root","reduceVar","name","limit","result","getValue","async","reduceFnc","functions","initval","func","getContext","fnc","arrval","params","param","ct","apply","message","calculateBind","me","extraarguments","link","formula","vars","vorc","createGetterAndSetter","BindTree","objdef","pro","BindDef","eventPRoxy","newval","addBind2Object","ref","BindMap","Map","tree","getBind2Object","delBind","delete","searchBind","encontrado","removeElements","elements","element","destroy","parentNode","removeChild","iterBind","btree","base","checkMarkEle","bresult","gen","show","remove","insertBefore","hide","insert","renderBind","render","getElementIndex","canrender","allok","checks","checkMarkRender","RenderElements","Elements","indexOf","createGTpl","objindex","elementos","row","refresh","generator","context","GTpl","ID","FncElements","BindConst","GtplChilds","Parent","Context","constructor","random","toString","slice","loadOptions","getGtplRoot","getRoot","svar","join","checkBindVar","preventDefault","checkBindEvent","checkBindFormula","startsWith","endsWith","changeEvent","initChangeEvents","simetric","original","getOwnPropertyDescriptor","checkSimetricBind","checkBind","launchChange","num","eles","addTo","render_arr","pa","updateTEXTbind","updateProperty","removeAttribute","getAttribute","attrs","filter","updateATTRbind","innerHTML","updateINNERbind","style","updateSTYLEbind","updateIFbind","delete_arr","isNaN","newgtpl","splice","ppath","update","rowinfo","renderindex","all","updateFORbind","case","gtplcase","refCase","mcobj","childNodes","nodeType","ca","uid","updateSWITCHbind","updateISbind","originalbind","marca","checkRenderElements","palabrasReservadas","GParse","l","r","arr_acepted","ln","setAceptedAN","getResult","getSingleResult","setString","str","acepted","from","map","c","charCodeAt","isAN","firstCanNumber","ok","code","checkStart","checkEnd","next","nop","cstop","cnow","getVOrC","getConst","getVar","point","into","clast","thereare","searchFormula","substring","findVars","ignoreall","ignore","declares","arrowIndex","cs","current","v","pop","some","list","gparse","gcont","gcontchar","regex_var","getGen","atributos","nodelist","getFunction","commongen","com","var","addGen2Obj","uuid","plus","jsonBind","Attributes2JSON","addGen2ObjConditional","bind_for","jsonAttr2","jsonAttr","parseAttribute","tt","attrObj","unshift","match","csstext","cssobj","entries","onlyone","json","JSON","stringify","subKey","subValue","fncParams","isAsync","fncBody","getId","letras","prefijo","floor","obtenerPrefijoChar","String","padStart","NodeList2Function","nodes","headers","bindSwitch","bind_switch","bind_case","bind_if","bind_is","bind_tpl","real","childsnodes","parse","tpl","getElementById","content","fetch","text","doc","DOMParser","parseFromString","trim","body","common","cases","ccase","normal","nodeValue","gcode","ggenerator","html","Node"],"sourceRoot":""}