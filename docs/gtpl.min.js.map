{"version":3,"file":"gtpl.min.js","mappings":"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","sources":["webpack://gtpl/webpack/universalModuleDefinition","webpack://gtpl/./src/compiler/GParse.ts","webpack://gtpl/./src/global.js","webpack://gtpl/./src/compiler/GCode.ts","webpack://gtpl/./src/GUtils.ts","webpack://gtpl/./src/GProxy.ts","webpack://gtpl/./src/GTpl.ts","webpack://gtpl/./src/GGenerator.ts","webpack://gtpl/webpack/bootstrap","webpack://gtpl/webpack/runtime/define property getters","webpack://gtpl/webpack/runtime/global","webpack://gtpl/webpack/runtime/hasOwnProperty shorthand","webpack://gtpl/webpack/runtime/make namespace object","webpack://gtpl/./src/lib/gtpl.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gtpl\"] = factory();\n\telse\n\t\troot[\"gtpl\"] = factory();\n})(this, () => {\nreturn ","import { IVarOrConst, IFunction, IObjParsed, TplVar } from '../GGenerator';\nimport { globalObject } from '../global.js';\n\nconst palabrasReservadas = [\n    \"abstract\", \"await\", \"boolean\", \"break\", \"byte\", \"case\", \"catch\",\n    \"char\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\",\n    \"do\", \"double\", \"else\", \"enum\", \"export\", \"extends\", \"false\", \"final\",\n    \"finally\", \"float\", \"for\", \"function\", \"goto\", \"if\", \"implements\", \"import\",\n    \"in\", \"instanceof\", \"int\", \"interface\", \"let\", \"long\", \"native\", \"new\",\n    \"null\", \"package\", \"private\", \"protected\", \"public\", \"return\", \"short\",\n    \"static\", \"super\", \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n    \"transient\", \"true\", \"try\", \"typeof\", \"var\", \"void\", \"volatile\", \"while\",\n    \"with\", \"yield\", \"arguments\", \"await\", \"async\", \"eval\", \"undefined\"\n];\n\nexport class GParse {\n\n    private s!: string;\n    private i!: number;\n    private l!: number;\n    private r!: (string | IObjParsed)[];\n    private arr_acepted!: number[];\n    private ln!: string | null;\n\n    constructor() {\n        this.setAceptedAN();\n    }\n\n    getResult(): (string | IObjParsed)[] {\n        return this.r;\n    }\n\n    getSingleResult(): IObjParsed {\n        let result: any = null;\n        if (this.r && this.r.length == 1)\n            result = this.r[0];\n        return result;\n    }\n\n    setString(str: string) {\n        this.s = str;\n        this.l = str.length;\n        this.i = 0;\n        this.r = [];\n    }\n\n    setAceptedAN(acepted: string = '_') {\n        this.arr_acepted = Array.from(acepted).map((c: string) => c.charCodeAt(0));\n    }\n\n    checkStart(): boolean {\n        return (this.i + 1 < this.l) && (this.s[this.i] === '{' && this.s[this.i + 1] === '{');\n    }\n\n    checkEnd(): boolean {\n        return (this.i + 1 < this.l) && (this.s[this.i] === '}' && this.s[this.i + 1] === '}');\n    }\n\n    next() {\n        this.i++;\n        if (this.i >= this.l)\n            return false;\n        return true;\n    }\n\n    nop(all: boolean = false, cstop: string[] | null = null): boolean {\n        let cnow: null | string = null;\n        this.ln = null;\n        while (true) {\n            cnow = this.s[this.i];\n            if (cstop && cstop.includes(cnow))\n                return true;\n            let ok = (cnow == ' ' || cnow == '\\t' || cnow == '\\r' || cnow == '\\n');\n            if (!ok && all) {\n                ok = (cnow != '\"' && cnow != \"'\" && !this.isAN(cnow));\n                if (ok) {\n                    this.ln = cnow;\n                }\n            }\n            if (ok) {\n                if (!this.next())\n                    return false;\n                continue;\n            }\n            return true;\n        }\n    }\n\n    isAN(str: string, firstCanNumber: boolean = true) {\n        if (str == undefined)\n            return false;\n        let ok: boolean;\n        for (let i = 0, n = str.length, code = 0; i < n; i++) {\n            code = str.charCodeAt(i);\n            ok = (code > 64 && code < 91) || (code > 96 && code < 123) || this.arr_acepted.indexOf(code) >= 0;\n            if (firstCanNumber)\n                ok = ok || (code > 47 && code < 58);\n            if (ok)\n                continue;\n            return false\n        }\n        return true;\n    }\n\n    getVOrC(): null | IVarOrConst {\n        let cnow = this.s[this.i];\n        if (cnow == '\"' || cnow == \"'\") {\n            return { ct: this.getConst() };\n        } else if (this.isAN(cnow, false)) {\n            return { va: this.getVar() };\n        } else if (this.isNumber(cnow)) {\n            const temp = this.i;\n            const num = this.getNumber();\n            if (num !== null)\n                return { ct: num };\n            this.i = temp;\n        }\n        return null;\n    }\n\n    getVar(point: boolean = true): null | string[] {\n        let str = this.s[this.i], cnow: null | string = null, acepted: boolean;\n        while (true) {\n            if (!this.next())\n                return str != '' ? str.split('.') : null;\n            cnow = this.s[this.i];\n            acepted = this.isAN(cnow);\n            if (point && !acepted)\n                acepted = cnow == '.';\n            if (acepted) {\n                str += cnow;\n                continue;\n            } else {\n                return str.split('.');\n            }\n        };\n    }\n\n    getConst(): null | string {\n        const into = this.s[this.i];\n        if (!this.next())\n            return null;\n        let str = this.s[this.i];\n        if (str == into) {\n            str = '';\n            if (!this.next())\n                return null;\n            return str;\n        }\n        let cnow: null | string = null, clast: null | string = null;\n        while (true) {\n            if (!this.next())\n                return null;\n            cnow = this.s[this.i];\n            if (cnow == into && clast != '\\\\') {\n                if (!this.next())\n                    return null;\n                return str;\n            }\n            str += cnow;\n            clast = cnow;\n        }\n    }\n\n    isNumber(char: string): boolean {\n        const code = char.charCodeAt(0);\n        return code >= 48 && code <= 57;\n    }\n\n    getNumber(): null | string {\n        let str = this.s[this.i];\n        let cnow: null | string = null;\n        let hasDecimalPoint = false;\n        while (true) {\n            if (!this.next())\n                break;\n            cnow = this.s[this.i];\n            if (cnow == '.') {\n                if (hasDecimalPoint)\n                    return null;\n                hasDecimalPoint = true;\n            } else if (!this.isNumber(cnow)) {\n                break;\n            }\n            str += cnow;\n        }\n        return str;\n    }\n\n    check(): boolean {\n\n        let i = 0;\n        let temp = '';\n        let obj: IObjParsed;\n        let vorc: null | IVarOrConst;\n        let cnow: string;\n        let thereare: boolean = false;\n\n        while (true) {\n\n            if (this.checkStart()) {\n\n                thereare = true;\n\n                if (temp != '') {\n                    this.r.push(temp);\n                    temp = '';\n                }\n\n                obj = {};\n\n                this.i += 2;\n\n                i = this.i;\n\n                if (!this.nop())\n                    return false;\n\n                vorc = this.getVOrC();\n\n                if (vorc) {\n\n                    obj.vorc = vorc;\n\n                    while (true) {\n\n                        if (!this.nop())\n                            return false;\n\n                        cnow = this.s[this.i];\n\n                        if (cnow == ':') {\n\n                            if (!this.next())\n                                return false;\n\n                            if (!this.nop())\n                                return false;\n\n                            const fnc = this.getVar();\n\n                            if (fnc === null)\n                                return false;\n\n                            if (!obj.functions)\n                                obj.functions = [];\n\n                            const func: IFunction = { name: fnc };\n\n                            obj.functions.push(func);\n\n                            if (!this.nop())\n                                return false;\n\n                            cnow = this.s[this.i];\n\n                            if (cnow == '(') {\n\n                                if (!this.next())\n                                    return false;\n\n                                if (!this.nop())\n                                    return false;\n\n                                cnow = this.s[this.i];\n\n                                if (cnow == undefined)\n                                    break;\n\n                                if (cnow == ')') {\n                                    if (!this.next())\n                                        return false;\n                                    continue;\n                                }\n\n                                while (true) {\n\n                                    vorc = this.getVOrC();\n\n                                    if (!vorc)\n                                        return false;\n\n                                    if (!func.params)\n                                        func.params = [];\n\n                                    func.params.push(vorc);\n\n                                    if (!this.nop())\n                                        return false;\n\n                                    cnow = this.s[this.i];\n\n                                    if (cnow == undefined)\n                                        break;\n\n                                    if (cnow == ',') {\n                                        if (!this.next())\n                                            return false;\n                                        if (!this.nop())\n                                            return false;\n                                        continue;\n                                    }\n\n                                    if (cnow == ')') {\n                                        if (!this.next())\n                                            return false;\n                                        if (!this.nop())\n                                            return false;\n                                        break;\n                                    }\n\n                                }\n\n                            }\n\n                            continue;\n\n                        }\n\n                        break;\n\n                    }\n\n                    cnow = this.s[this.i];\n\n                    if (cnow == '{') {\n\n                        if (!this.next())\n                            return false;\n\n                        while (true) {\n\n                            if (!this.nop())\n                                return false;\n\n                            cnow = this.s[this.i];\n\n                            if (cnow == undefined)\n                                break;\n\n                            if (cnow == '}') {\n                                if (!this.next())\n                                    return false;\n                                if (!this.nop())\n                                    return false;\n                                break;\n                            }\n\n                            // Si se encuentra una coma, se omite y se contina\n                            if (cnow == ',') {\n                                if (!this.next())\n                                    return false;\n                                continue;\n                            }\n\n                            vorc = this.getVOrC();\n\n                            if (!vorc)\n                                return false;\n\n                            if (!obj.params)\n                                obj.params = [];\n\n                            obj.params.push(vorc);\n                        }\n                    }\n\n                    cnow = this.s[this.i];\n\n                    if (cnow == ';') {\n\n                        if (!this.next())\n                            return false;\n\n                        if (!this.nop())\n                            return false;\n\n                        const index = this.getVar(false);\n\n                        if (index === null)\n                            return false;\n\n                        if (!this.nop())\n                            return false;\n\n                        cnow = this.s[this.i];\n\n                        if (cnow == ';') {\n\n                            if (!this.next())\n                                return false;\n\n                            if (!this.nop())\n                                return false;\n\n                            const target = this.getVar(false);\n\n                            if (target === null)\n                                return false;\n\n                            obj.index = { index: index.join(''), target: target.join('') };\n\n                        } else {\n\n                            return false;\n\n                        }\n\n                    }\n\n                    if (!this.nop())\n                        return false;\n\n                    if (this.checkEnd()) {\n\n                        this.i++;\n\n                        this.r.push(obj);\n\n                    } else {\n\n                        if (!this.searchFormula(i))\n                            return false;\n\n                    }\n\n                } else {\n\n                    if (!this.searchFormula(i))\n                        return false;\n\n                }\n\n            } else {\n\n                temp += this.s[this.i];\n\n            }\n\n            if (!this.next())\n                break;\n\n        }\n\n        if (temp != '')\n            this.r.push(temp);\n\n        return thereare;\n\n    }\n\n    searchFormula(i: number): boolean {\n\n        let temp = this.s.substring(i, this.i);\n\n        while (true) {\n\n            if (this.checkEnd()) {\n\n                this.i++;\n\n                this.r.push({ formula: { code: temp, vars: this.findVars(temp) } });\n\n                temp = '';\n\n                break;\n\n            } else {\n\n                temp += this.s[this.i];\n\n                if (!this.next())\n                    return false;\n\n            }\n\n        }\n\n        return true;\n    }\n\n    findVars(str: string): TplVar[] {\n\n        let codeToParse = str.trim();\n\n        // Guardar estado original\n        const originalS = this.s;\n        const originalI = this.i;\n        const originalL = this.l;\n\n        // Inicializar con el cdigo a analizar\n        this.s = codeToParse;\n        this.l = codeToParse.length;\n        this.i = 0;\n        let freeVars: TplVar[] = [];\n        // Pila de mbitos para registrar variables declaradas localmente\n        let ignoreStack: string[][] = [[]];\n\n        const addToIgnore = (name: string) => {\n            ignoreStack[ignoreStack.length - 1].push(name);\n        };\n\n        const isIgnored = (name: string) => {\n            return ignoreStack.some(ctx => ctx.indexOf(name) >= 0);\n        };\n\n        const skipWhitespace = () => {\n            while (this.i < this.l && /\\s/.test(this.s[this.i])) {\n                this.i++;\n            }\n        };\n\n        const skipStringLiteral = (quote: string) => {\n            this.i++; // saltar la apertura\n            while (this.i < this.l) {\n                if (this.s[this.i] === '\\\\') {\n                    this.i += 2;\n                } else if (this.s[this.i] === quote) {\n                    this.i++;\n                    break;\n                } else {\n                    this.i++;\n                }\n            }\n        };\n\n        const skipTemplateLiteral = () => {\n            this.i++; // saltar el backtick de apertura\n            while (this.i < this.l) {\n                if (this.s[this.i] === '\\\\') {\n                    this.i += 2;\n                } else if (this.s[this.i] === '$' && this.s[this.i + 1] === '{') {\n                    this.i += 2; // saltar \"${\"\n                    let braceCount = 1;\n                    const exprStart = this.i;\n                    while (this.i < this.l && braceCount > 0) {\n                        if (this.s[this.i] === '{') {\n                            braceCount++;\n                        } else if (this.s[this.i] === '}') {\n                            braceCount--;\n                        }\n                        this.i++;\n                    }\n                    // Procesar la expresin incrustada de forma recursiva\n                    const expr = this.s.substring(exprStart, this.i - 1);\n                    const subVars = this.findVars(expr);\n                    subVars.forEach(token => {\n                        if (!isIgnored(token[0]) && !freeVars.some(v => v[0] === token[0])) {\n                            freeVars.push(token);\n                        }\n                    });\n                } else if (this.s[this.i] === '`') {\n                    this.i++; // saltar el backtick de cierre\n                    break;\n                } else {\n                    this.i++;\n                }\n            }\n        };\n\n        // Utiliza el mtodo getVOrC() existente para extraer tokens (variables o literales)\n        const extractToken = (): TplVar | null => {\n            // Capturamos la posicin de inicio del token\n            const tokenStart = this.i;\n            const tokenObj = this.getVOrC();\n            if (tokenObj && tokenObj.va) {\n                // Retrocedemos ignorando espacios en blanco\n                let j = tokenStart - 1;\n                while (j >= 0 && /\\s/.test(this.s[j])) {\n                    j--;\n                }\n                // Si encontramos un punto antes, descartamos el token\n                if (j >= 0 && this.s[j] === '.') {\n                    return null;\n                }\n                return tokenObj.va;\n            }\n            return null;\n        };\n\n        // Intenta procesar parmetros de arrow function: (a, b) =>\n        const tryParseArrowParams = () => {\n            if (this.s[this.i] !== '(') return false;\n            const startParen = this.i;\n            let parenCount = 0;\n            while (this.i < this.l) {\n                const ch = this.s[this.i];\n                if (ch === '(') {\n                    parenCount++;\n                } else if (ch === ')') {\n                    parenCount--;\n                    if (parenCount === 0) break;\n                }\n                this.i++;\n            }\n            const paramsStr = this.s.substring(startParen + 1, this.i);\n            this.i++; // saltar el cierre ')'\n            skipWhitespace();\n            if (this.s.substr(this.i, 2) === '=>') {\n                paramsStr.split(',').forEach(param => {\n                    const trimmed = param.trim();\n                    if (trimmed) addToIgnore(trimmed);\n                });\n                this.i += 2; // saltar \"=>\"\n                return true;\n            }\n            return false;\n        };\n\n        // Deteccin especial para la clusula catch: catch(error)\n        const tryParseCatchClause = () => {\n            if (this.s.substr(this.i, 5) === \"catch\") {\n                this.i += 5; // saltar \"catch\"\n                skipWhitespace();\n                if (this.s[this.i] === '(') {\n                    this.i++; // saltar \"(\"\n                    skipWhitespace();\n                    const errorToken = extractToken();\n                    if (errorToken) {\n                        addToIgnore(errorToken[0]);\n                    }\n                    // Saltar hasta el cierre \")\"\n                    while (this.i < this.l && this.s[this.i] !== ')') {\n                        this.i++;\n                    }\n                    if (this.s[this.i] === ')') {\n                        this.i++;\n                    }\n                }\n                return true;\n            }\n            return false;\n        };\n\n        // Manejo especial para declaraciones de funciones\n        const tryParseFunctionDeclaration = () => {\n            // Si se detecta la palabra \"function\"\n            if (this.s.substr(this.i, 8) === \"function\") {\n                this.i += 8;\n                // Opcionalmente, se puede extraer el nombre de la funcin\n                skipWhitespace();\n                const maybeName = extractToken();\n                if (maybeName) {\n                    addToIgnore(maybeName[0]);\n                }\n                skipWhitespace();\n                // Procesar los parmetros que vienen entre parntesis\n                if (this.s[this.i] === '(') {\n                    this.i++; // saltar '('\n                    let params = \"\";\n                    while (this.i < this.l && this.s[this.i] !== ')') {\n                        params += this.s[this.i];\n                        this.i++;\n                    }\n                    if (this.s[this.i] === ')') {\n                        this.i++; // saltar ')'\n                    }\n                    params.split(',').forEach(param => {\n                        const trimmed = param.trim();\n                        if (trimmed) addToIgnore(trimmed);\n                    });\n                }\n                return true;\n            }\n            return false;\n        };\n\n        // Palabras clave para declaraciones (adems de las reservadas)\n        const declares = ['const', 'var', 'let', 'function'];\n\n        // Bucle principal de anlisis\n        while (this.i < this.l) {\n            skipWhitespace();\n            if (this.i >= this.l) break;\n            const ch = this.s[this.i];\n\n            // Procesar clusula catch para declarar su variable\n            if (this.s.substr(this.i, 5) === \"catch\") {\n                tryParseCatchClause();\n                continue;\n            }\n\n            // Procesar declaraciones de funcin\n            if (this.s.substr(this.i, 8) === \"function\") {\n                tryParseFunctionDeclaration();\n                continue;\n            }\n\n            // Saltar comentarios de lnea y bloque\n            if (ch === '/' && this.s[this.i + 1] === '/') {\n                this.i += 2;\n                while (this.i < this.l && this.s[this.i] !== '\\n') this.i++;\n                continue;\n            }\n            if (ch === '/' && this.s[this.i + 1] === '*') {\n                this.i += 2;\n                while (this.i < this.l && !(this.s[this.i] === '*' && this.s[this.i + 1] === '/')) this.i++;\n                this.i += 2;\n                continue;\n            }\n            // Saltar literales de cadena\n            if (ch === '\"' || ch === \"'\") {\n                skipStringLiteral(ch);\n                continue;\n            }\n            // Procesar template literal\n            if (ch === '`') {\n                skipTemplateLiteral();\n                continue;\n            }\n            // Control de mbito: cuando se abre un bloque, se agrega un nuevo contexto; se elimina al cerrar\n            if (ch === '{') {\n                ignoreStack.push([]);\n                this.i++;\n                continue;\n            }\n            if (ch === '}') {\n                ignoreStack.pop();\n                this.i++;\n                continue;\n            }\n            // Detectar parmetros de arrow function\n            if (ch === '(') {\n                const prevI = this.i;\n                if (tryParseArrowParams()) continue;\n                else this.i = prevI;\n            }\n\n            // Intentar extraer un token (variable o literal numrico)\n            const token = extractToken();\n            if (token) {\n                // Si el token es palabra clave de declaracin, se espera el siguiente token (la variable a declarar)\n                if (declares.indexOf(token[0]) >= 0) {\n                    skipWhitespace();\n                    const declared = extractToken();\n                    if (declared) {\n                        addToIgnore(declared[0]);\n                    }\n                    continue;\n                }\n                // Filtrar variables globales (por ejemplo, Math, etc.) y palabras reservadas\n                if (globalObject[token[0]] !== undefined) {\n                    continue;\n                }\n                if (palabrasReservadas.indexOf(token[0]) >= 0) {\n                    continue;\n                }\n                // Evitar tokens que formen parte de la sintaxis de un objeto (si le sigue \":\")\n                let j = this.i;\n                while (j < this.l && /\\s/.test(this.s[j])) { j++; }\n                if (this.s[j] === ':') {\n                    continue;\n                }\n                // Si ya se declar en algn mbito, se ignora\n                if (isIgnored(token[0])) continue;\n                // Se agrega a freeVars solo si an no est incluido\n                if (!freeVars.some(v => v[0] === token[0])) {\n                    freeVars.push(token);\n                }\n                continue;\n            }\n            // Avanzar un carcter para evitar bucles infinitos\n            this.i++;\n        }\n\n        // Restaurar estado original\n        this.s = originalS;\n        this.i = originalI;\n        this.l = originalL;\n        return freeVars;\n    }\n\n\n}","//---\n\nlet temp = null;\n\nfunction check(it) {\n    return it && it.Math === Math && it;\n}\n\ntry {\n    temp =\n        check(typeof globalThis === 'object' && globalThis) ||\n        check(typeof window === 'object' && window) ||\n        check(typeof self === 'object' && self) ||\n        check(typeof global === 'object' && global) ||\n        (function () { return this; })() ||\n        Function('return this')();\n} catch (ex) {\n\n}\n\nexport const globalObject = temp;\n\n//---\n\nlet ptemp = null;\n\ntry {\n    const options = {\n        get passive() {\n            ptemp = true;\n            return false;\n        },\n    };\n    globalObject.addEventListener(\"test\", null, options);\n    globalObject.removeEventListener(\"test\", null, options);\n} catch (err) {\n    ptemp = false;\n}\n\nexport const passiveSupported = ptemp;\n\n//---","import { NodeTypes, BindTypes } from '../GEnums';\nimport { GParse } from './GParse';\nimport { IBindObject, IFormula, IObjParsed } from '../GGenerator';\nimport { css2obj, log, style2css } from '../GUtils';\nimport { AttrType, ProGen } from '../GGenerator';\nimport { globalObject } from '../global';\n\nlet gparse!: GParse;\nlet gcont: number = 0;\nlet gcontchar: number = 0;\nconst regex_var = /([a-zA-Z\\_][\\w]+)\\s*\\=\\s*([a-zA-Z][\\w\\.]+)/gi;\n\nfunction getGen(nodeName: string, atributos: string | null, nodelist?: string | null): string {\n    return 'g(\\'' + nodeName + '\\',' + (atributos ? atributos : 'null') + ',' + (nodelist ? nodelist : 'null') + ',o)';\n}\n\nfunction getFunction(gen: string, parent?: any, commongen?: any): string {\n    if (commongen) {\n        let str: string[] = [];\n        commongen.forEach((com: any) => {\n            str.push('const ' + com.var + '=' + com.gen + ';');\n        });\n        return '((o)=>{' + str.join('') + 'return ' + gen + '})' + (!parent ? '(o)' : '');\n    }\n    return '((o)=>' + gen + ')' + (!parent ? '(o)' : '');\n}\n\nfunction addGen2Obj(bind: IBindObject, uuid: null | string, gen?: ProGen, plus?: string) {\n    let jsonBind: string = Attributes2JSON([bind], true);\n    jsonBind = jsonBind.substring(0, jsonBind.length - 1);\n    jsonBind = jsonBind + ',\"gen\":' + (gen ? gen : uuid) + (plus ? plus : '') + '}';\n    return jsonBind;\n}\n\nfunction addGen2ObjConditional(bind: IBindObject, uuid: string, bind_for: IBindObject | null, jsonAttr2: string, jsonAttr: string, plus?: string) {\n    bind.uid = uuid;\n    if (bind_for) {\n        if (jsonAttr2 != '')\n            jsonAttr2 += ',';\n        jsonAttr2 += addGen2Obj(bind, uuid, undefined, plus);\n    } else {\n        if (jsonAttr != '')\n            jsonAttr += ',';\n        jsonAttr += addGen2Obj(bind, uuid, undefined, plus);\n    }\n    return { jsonAttr2, jsonAttr };\n}\n\nfunction parseAttribute(atributos: AttrType[], prop: string, value: string): boolean {\n    let tt: null | BindTypes = null;\n    switch (prop) {\n        case 'g-is':\n            tt = tt || BindTypes.IS;\n        case 'g-binds':\n            tt = tt || BindTypes.ELES;\n        case 'g-bind':\n            tt = tt || BindTypes.ELE;\n        case 'g-attr':\n            tt = tt || BindTypes.ATTR;\n        case 'g-if':\n            tt = tt || BindTypes.IF;\n        case 'g-notif':\n            tt = tt || BindTypes.NOTIF;\n        case 'g-switch':\n            tt = tt || BindTypes.SWITCH;\n        case 'g-case':\n            tt = tt || BindTypes.CASE;\n        case 'g-for':\n            tt = tt || BindTypes.FOR;\n        case 'g-inner':\n            tt = tt || BindTypes.INNER;\n            gparse.setString(`{{${value}}}`);\n            if (gparse.check()) {\n                const attrObj = {\n                    type: tt,\n                    link: gparse.getSingleResult()\n                };\n                if (tt === BindTypes.IS) {\n                    atributos.unshift(attrObj);\n                } else {\n                    atributos.push(attrObj);\n                }\n                return true;\n            }\n            break;\n        case 'g-var':\n            tt = tt || BindTypes.VAR;\n            if (value.match(regex_var)) {\n                const vars = value.split(regex_var);\n                atributos.push({\n                    type: tt,\n                    link: {\n                        svar: vars[1],\n                        vorc: {\n                            va: vars[2].split('.')\n                        }\n                    }\n                });\n                return true;\n            }\n            break;\n        case 'g-tpl':\n            tt = tt || BindTypes.TPL;\n            atributos.push({\n                type: tt,\n                link: {\n                    vorc: {\n                        ct: value\n                    }\n                }\n            });\n            return true;\n        case 'g-style':\n            if (!value.includes('{{'))\n                value = `{{${value}}}`;\n        case 'style':\n            let csstext: string = '';\n            gparse.setString(value);\n            if (gparse.check()) {\n                let r: any = gparse.getResult();\n                if (r && r.length) {\n                    if (r.length == 1) {\n                        atributos.push({\n                            type: BindTypes.STYLE,\n                            prop: 'cssText',\n                            link: <any>r[0]\n                        });\n                        return true;\n                    }\n                    const cssobj = css2obj(value);\n                    for (const [key, val] of Object.entries(cssobj)) {\n                        gparse.setString(<string>val);\n                        if (gparse.check()) {\n                            r = gparse.getSingleResult();\n                            atributos.push({\n                                type: BindTypes.STYLE,\n                                prop: key,\n                                link: r\n                            });\n                        } else {\n                            csstext += csstext ? ';' : '';\n                            csstext += `${style2css(key)}:${val}`;\n                        }\n                    }\n                    if (csstext != '')\n                        atributos.push(['style', csstext]);\n                    return true;\n                }\n            }\n            break;\n        default:\n            gparse.setString(value);\n            if (gparse.check()) {\n                const r = gparse.getResult();\n                if (r && r.length == 1) {\n                    const attrObj = {\n                        type: prop.startsWith('on') ? BindTypes.EVENT : BindTypes.ATTR,\n                        prop: prop.startsWith('on') ? prop.substring(2) : prop,\n                        link: <any>r[0]\n                    };\n                    atributos.push(attrObj);\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\n\n/*\nfunction Attributes2JSON(atributos: AttrType[], onlyone: boolean = false): string {\n    const json: string[] = [];\n    atributos.forEach((attr: AttrType) => {\n        if (Array.isArray(attr) || typeof attr == 'string') {\n            json.push(JSON.stringify(attr));\n        } else {\n            const bind: IBindObject = <IBindObject>attr;\n            if (bind.link && bind.link.formula) {\n                const obj: string[] = [];\n                for (let i in bind) {\n                    const nivel1: any = (<any>bind)[i];\n                    if (obj.length)\n                        obj.push(',');\n                    if (i == 'link') {\n                        obj.push('\"link\":{');\n                        for (let ii in nivel1) {\n                            const nivel2 = nivel1[ii];\n                            if (obj[obj.length - 1] != '\"link\":{')\n                                obj.push(',');\n                            if (ii == 'formula') {\n                                obj.push('\"formula\":{');\n                                if (nivel2.vars)\n                                    obj.push('\"vars\":' + JSON.stringify(nivel2.vars) + ',');\n                                let isasync = '';\n                                if (nivel2.code.match(/[\\s\\;\\r\\n]await[\\W]/gm))\n                                    isasync = ' async ';\n                                if (nivel2.code.match(/[\\s\\;\\r\\n]return[\\W]/gm)) {\n                                    obj.push('\"fnc\":' + isasync + 'function(' +\n                                        (nivel2.vars ? (nivel2.vars.map((arr: any) => arr[0]).join(',')) : '') +\n                                        '){' +\n                                        nivel2.code +\n                                        '}');\n                                } else {\n                                    obj.push('\"fnc\":' + isasync + 'function(' +\n                                        (nivel2.vars ? (nivel2.vars.map((arr: any) => arr[0]).join(',')) : '') +\n                                        '){return(' +\n                                        nivel2.code +\n                                        ')}');\n                                }\n                                obj.push('}');\n                            } else {\n                                obj.push(JSON.stringify(ii) + ':' + JSON.stringify(nivel2));\n                            }\n                        }\n                        obj.push('}');\n                    } else {\n                        obj.push(JSON.stringify(i) + ':' + JSON.stringify(nivel1));\n                    }\n                }\n                json.push('{' + obj.join('') + '}');\n            } else {\n                json.push(JSON.stringify(attr));\n            }\n        }\n    });\n    if (onlyone)\n        return json.join(',');\n    return '[' + json.join(',') + ']';\n}\n*/\n\nfunction Attributes2JSON(atributos: AttrType[], onlyone: boolean = false): string {\n    const json = atributos.map(attr => {\n        if (Array.isArray(attr) || typeof attr === 'string') {\n            return JSON.stringify(attr);\n        } else {\n            const bind = attr as IBindObject;\n            if (bind.link?.formula) {\n                const obj = Object.entries(bind).map(([key, value]) => {\n                    if (key === 'link') {\n                        const linkObj = Object.entries(value).map(([subKey, subValue]) => {\n                            if (subKey === 'formula') {\n                                const { vars, code } = subValue as IFormula;\n                                if (code != undefined) {\n                                    const fncParams = vars?.map(v => v[0]).join(',') || '';\n                                    const isAsync = code.match(/[\\s;]await[\\W]/gm) ? ' async ' : '';\n                                    const fncBody = `{${code}}`;\n                                    return `\"${subKey}\":{\"vars\":${JSON.stringify(vars)},\"fnc\":${isAsync}function(${fncParams})${fncBody}}`;\n                                } else {\n                                    log('formula without code');\n                                }\n                            }\n                            return `\"${subKey}\":${JSON.stringify(subValue)}`;\n                        }).join(',');\n                        return `\"${key}\":{${linkObj}}`;\n                    }\n                    return `\"${key}\":${JSON.stringify(value)}`;\n                }).join(',');\n                return `{${obj}}`;\n            } else {\n                return JSON.stringify(attr);\n            }\n        }\n    });\n    return onlyone ? json.join(',') : `[${json.join(',')}]`;\n}\n\nfunction obtenerPrefijoChar(n: number) {\n    const letras = 'abcdefghijklmnopqrstuvwxyz';\n    let prefijo = '';\n    prefijo += letras[Math.floor(n / letras.length)];\n    prefijo += letras[n % letras.length];\n    return prefijo;\n}\n\nfunction getId() {\n    gcont++;\n    if (gcont > 9999) {\n        gcontchar = 1;\n        gcontchar++;\n    }\n    return obtenerPrefijoChar(gcontchar) + String(gcont).padStart(4, '0');\n}\n\nasync function NodeList2Function(nodes: NodeListOf<ChildNode> | Node[], parent?: any, headers?: boolean, bindSwitch?: null | IBindObject): Promise<string> {\n    //---\n    if (gparse == null)\n        gparse = new GParse();\n    //---\n    let parse: string = '';\n    if (headers !== false)\n        parse = '[';\n    //---\n    let bind_for: null | IBindObject,\n        bind_switch: null | IBindObject,\n        bind_case: null | IBindObject,\n        bind_if: null | IBindObject,\n        bind_is: null | IBindObject,\n        bind_tpl: null | IBindObject;\n    let ele: HTMLElement, real: undefined | HTMLElement | Node;\n    let childs: NodeListOf<ChildNode>;\n    let childsnodes: string,\n        jsonAttr: string,\n        jsonAttr2: string,\n        jsonBind: string,\n        attrs: string;\n    let atributos: AttrType[];\n    let uuid: string;\n    //---\n    for (var i = 0, fin = nodes.length; i < fin; i++) {\n        var node = nodes[i];\n        bind_for = bind_switch = bind_case = bind_if = bind_is = bind_tpl = null;\n        childsnodes = jsonAttr = jsonAttr2 = jsonBind = attrs = '';\n        switch (node.nodeType) {\n            case NodeTypes.ELEMENT_NODE:\n                {\n                    //---\n                    if (node.nodeName.toLowerCase() == 'script') {\n                        if (parse != '[')\n                            parse += ',';\n                        parse += getGen(node.nodeName, JSON.stringify(node.textContent));\n                        continue;\n                    }\n                    //---\n                    ele = <HTMLElement>node;\n                    atributos = [];\n                    for (let i = 0, n = ele.attributes.length, ref: NamedNodeMap = ele.attributes; i < n; i++) {\n                        const attr = ref.item(i);\n                        if (attr) {\n                            if (!parseAttribute(atributos, attr.name, attr.value)) {\n                                atributos.push([attr.name, attr.value]);\n                            } else if (atributos.length) {\n                                const bind: any = atributos[atributos.length - 1];\n                                if (bind) {\n                                    if (bind.type == BindTypes.IS) {\n                                        bind_is = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.IF || bind.type == BindTypes.NOTIF) {\n                                        bind_if = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.FOR) {\n                                        bind_for = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.SWITCH) {\n                                        bind_switch = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.CASE) {\n                                        if (!bindSwitch)\n                                            throw new Error('not switch');\n                                        if (!bindSwitch.case)\n                                            bindSwitch.case = [];\n                                        bindSwitch.case.push(bind);\n                                        bind_case = <IBindObject>bind;\n                                        bind_case.index = bindSwitch.case.length - 1;\n                                        atributos.pop();\n                                    }\n                                    if (bind.type == BindTypes.TPL) {\n                                        bind_tpl = <IBindObject>bind;\n                                        atributos.pop();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    //---\n                    if (bind_for && bind_case)\n                        throw new Error('not for and case ' + Array.from(ele.attributes, (item) => item.name + '=\"' + item.value + '\"').join(' '));\n                    if (bind_if && bind_case)\n                        throw new Error('not if and case ' + Array.from(ele.attributes, (item) => item.name + '=\"' + item.value + '\"').join(' '));\n                    if (bind_is && (bind_case || bind_switch || bind_tpl))\n                        throw new Error('not is and ( case or switch ot tpl ) ' + Array.from(ele.attributes, (item) => item.name + '=' + item.value + '\"').join(' '));\n                    //---\n                    if (parse != '[' && parse != '')\n                        parse += ',';\n                    //---\n                    if (bind_tpl) {\n                        const ct: any = (<any>bind_tpl).link.vorc.ct;\n                        const tpl = globalObject.document.getElementById(ct);\n                        if (tpl) {\n                            real = (ele.nodeName.toLowerCase() == 'template') ? parent : ele;\n                            childs = (tpl.nodeName.toLowerCase() == 'template') ? (<any>tpl).content.childNodes : [tpl];\n                            childsnodes = await NodeList2Function(childs, real, true, bind_switch);\n                        } else {\n                            /** @TODO better fetch **/\n                            const tpl = await (await fetch(ct)).text();\n                            const parser = new DOMParser();\n                            const doc = parser.parseFromString(tpl.trim(), \"text/html\");\n                            childsnodes = await NodeList2Function(doc.body.childNodes, real, true, bind_switch);\n                        }\n                    } else {\n                        real = (ele.nodeName.toLowerCase() == 'template') ? (<any>ele).content : ele;\n                        childs = (<any>real).childNodes;\n                        childsnodes = await NodeList2Function(childs, real, true, bind_switch);\n                    }\n                    //---\n                    if (bind_is || bind_if || bind_case || bind_for || bind_switch) {\n\n                        uuid = getId();\n\n                        jsonAttr = '';\n                        jsonAttr2 = '';\n\n                        const common: any = [];\n\n                        attrs = Attributes2JSON(atributos);\n\n                        if (bind_is) {\n                            ({ jsonAttr2, jsonAttr } = addGen2ObjConditional(bind_is, uuid, bind_for, jsonAttr2, jsonAttr));\n                        }\n\n                        if (bind_if) {\n                            ({ jsonAttr2, jsonAttr } = addGen2ObjConditional(bind_if, uuid, bind_for, jsonAttr2, jsonAttr));\n                        }\n\n                        if (bind_switch) {\n                            bind_switch.uid = uuid;\n                            const cases = bind_switch.case;\n                            delete bind_switch.case;\n                            //---\n                            jsonBind = '';\n                            if (cases) {\n                                cases.forEach((ccase: IBindObject) => {\n                                    if (ccase.common) {\n                                        ccase.common.forEach((com: any) => common.push(com));\n                                        delete ccase.common;\n                                    }\n                                    if (ccase.gen) {\n                                        const gen = ccase.gen;\n                                        delete ccase.gen;\n                                        if (jsonBind != '')\n                                            jsonBind += ',';\n                                        jsonBind += addGen2Obj(ccase, null, gen);\n                                    }\n                                });\n                            }\n                            //---\n                            ({ jsonAttr2, jsonAttr } = addGen2ObjConditional(bind_switch, uuid, bind_for, jsonAttr2, jsonAttr, ',\"case\":[' + jsonBind + ']'));\n                            //---\n                        }\n\n                        if (bind_tpl) {\n\n                            if (ele.nodeName.toLowerCase() == 'template') {\n\n                                common.push({\n                                    'var': uuid,\n                                    'gen': childsnodes\n                                });\n\n                            } else {\n\n                                common.push({\n                                    'var': uuid,\n                                    'gen': getFunction(getGen(ele.nodeName, attrs, childsnodes), true)\n                                });\n\n                            }\n\n                        } else {\n\n                            common.push({\n                                'var': uuid,\n                                'gen': bind_is ? 'null' : getFunction(getGen(ele.nodeName, attrs, childsnodes), true)\n                            });\n\n                        }\n\n                        if (bind_case) {\n\n                            bind_case.uid = uuid;\n                            bind_case.gen = uuid;\n                            bind_case.common = common;\n\n                            parse += getFunction(getGen('#comment', '[' + JSON.stringify(uuid) + ',' + jsonAttr + ']'), parent);\n\n                        } else {\n\n                            if (bind_for) {\n\n                                if (bind_if || bind_is || bind_switch) {\n\n                                    bind_for.uid = getId();\n                                    if (jsonAttr != '')\n                                        jsonAttr += ',';\n                                    jsonAttr += addGen2Obj(bind_for, bind_for.uid);\n\n                                    // jsonAttr2 -> solo if, notif, switch, is ...\n\n                                    common.push({\n                                        'var': bind_for.uid,\n                                        'gen': getFunction(getGen('#comment', '[' + JSON.stringify(uuid) + ',' + jsonAttr2 + ']'), true)\n                                    });\n\n                                } else {\n\n                                    bind_for.uid = uuid;\n                                    if (jsonAttr != '')\n                                        jsonAttr += ',';\n                                    jsonAttr += addGen2Obj(bind_for, uuid);\n\n                                }\n\n                                // jsonAttr -> solo for\n\n                                parse += getFunction(getGen('#comment', '[' + JSON.stringify(bind_for.uid) + ',' + jsonAttr + ']'), parent, common);\n\n                            } else {\n\n                                // jsonAttr -> solo if, notif, switch, is ...\n\n                                parse += getFunction(getGen('#comment', '[' + JSON.stringify(uuid) + ',' + jsonAttr + ']'), parent, common);\n\n                            }\n\n                        }\n\n                    } else {\n\n                        if (bind_tpl) {\n\n                            if (ele.nodeName.toLowerCase() == 'template') {\n\n                                parse += childsnodes;\n\n                            } else {\n\n                                parse += getFunction(getGen(ele.nodeName, Attributes2JSON(atributos), childsnodes), parent);\n\n                            }\n\n                        } else {\n\n                            parse += getFunction(getGen(ele.nodeName, Attributes2JSON(atributos), childsnodes), parent);\n\n                        }\n\n                    }\n                    //---\n                }\n                break;\n            case NodeTypes.TEXT_NODE:\n                {\n                    let normal: boolean = true;\n                    if (node.nodeValue) {\n                        gparse.setString(node.nodeValue);\n                        if (gparse.check()) {\n                            normal = false;\n                            const r = gparse.getResult();\n                            if (r && r.length) {\n                                r.forEach((item: string | IObjParsed) => {\n                                    if (parse != '[' && parse != '')\n                                        parse += ',';\n                                    if (typeof item == 'string') {\n                                        parse += getGen(node.nodeName, JSON.stringify(item));\n                                    } else {\n                                        parse += getGen(node.nodeName, Attributes2JSON([{\n                                            type: BindTypes.TEXT,\n                                            prop: 'textContent',\n                                            link: item\n                                        }]));\n                                    }\n                                });\n                            }\n                        }\n                    }\n                    if (normal) {\n                        if (parse != '[' && parse != '')\n                            parse += ',';\n                        parse += getGen(node.nodeName, JSON.stringify(node.nodeValue));\n                    }\n                }\n                break;\n            case NodeTypes.COMMENT_NODE:\n                {\n                    if (parse != '[' && parse != '')\n                        parse += ',';\n                    parse += getGen(node.nodeName, JSON.stringify(node.nodeValue));\n                }\n                break;\n        }\n    };\n    if (headers !== false)\n        parse += ']';\n    if (parent === undefined)\n        return '(o)=>' + parse;\n    return parse;\n}\n\nexport async function GCode(html: string | Node | NodeListOf<ChildNode>): Promise<string> {\n    if (typeof html == 'string') {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html.trim(), \"text/html\");\n        return NodeList2Function(doc.body.childNodes);\n    } else {\n        return NodeList2Function(html instanceof Node ? [html] : html);\n    }\n}","\nexport function css2obj(css: string): Record<string, string> {\n    const obj: Record<string, string> = {};\n    const s = css.toLowerCase()\n        .replace(/-(.)/g, (m, g) => g.toUpperCase())\n        .replace(/;\\s?$/g, \"\")\n        .split(/:|;/g);\n    for (let i = 0, n = s.length; i < n; i += 2) {\n        obj[s[i].replace(/\\s/g, \"\")] = s[i + 1].replace(/^\\s+|\\s+$/g, \"\");\n    }\n    return obj;\n}\n\nexport function style2css(prop: any) {\n    return prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLocaleLowerCase();\n}\n\nconst typeArray = ['symbol', 'bigint', 'undefined', 'boolean', 'string', 'number'];\n\nexport function isStaticType(val: any): boolean {\n    if (val === null || val === undefined)\n        return true;\n    const type = typeof val;\n    return typeArray.includes(type);\n}\n\nexport function log(...args: any): void {\n    console.log('%c----------', 'font-weight:bold');\n    args.forEach((arg: any) => {\n        console.log(arg);\n    });\n    console.log('%c----------', 'font-weight:bold');\n}\n\nexport function STACK(...args: any) {\n    //const functionName = log.caller?.name || arguments.callee.caller?.name;\n    args.push((new Error(args.shift())).stack);\n    log(...args);\n}\n","// GProxy.ts\nimport { TypeEventProxyHandler } from './GEnums';\nimport { isStaticType } from './GUtils';\n\nexport type PathProxyHandler = any;\nexport type EventFunctionProxyHandler = (\n  type: TypeEventProxyHandler,\n  path: PathProxyHandler,\n  value: any,\n  objRef: any\n) => void;\n\nexport const ISPROXY = Symbol('is proxy');\nexport const PROXYTARGET = Symbol('proxy target');\n\nconst proxyCache = new WeakMap<object, { proxy: any; revoke: () => void }>();\nconst handlersMap = new WeakMap<object, Set<EventFunctionProxyHandler>>();\n\nconst fakeEventHandler: EventFunctionProxyHandler = () => { }; // siempre la misma\n\nexport function isGProxy(obj: any): obj is { [ISPROXY]: true;[PROXYTARGET]: any } {\n  return !!obj && typeof obj === 'object' && ISPROXY in obj;\n}\n\nfunction getProxyHandler(\n  targetOriginal: any,\n  objRef: any,\n  parentPath: PathProxyHandler = []\n): ProxyHandler<any> {\n  return {\n    get(target, prop, receiver) {\n      if (prop === ISPROXY) return true;\n      if (prop === PROXYTARGET) return targetOriginal;\n      if (prop === Symbol.iterator) {\n        const origIter = (target as any)[Symbol.iterator].bind(target);\n        return function* () {\n          for (const item of origIter()) {\n            yield (isStaticType(item) || isGProxy(item))\n              ? item\n              : createGProxy(item, fakeEventHandler, objRef, [...parentPath, Symbol.iterator]);\n          }\n        };\n      }\n      const val = Reflect.get(target, prop, receiver);\n      if (isStaticType(val) || isGProxy(val)) return val;\n      return createGProxy(val, fakeEventHandler, objRef, [...parentPath, prop]);\n    },\n    set(target, prop, value, receiver) {\n      if (isGProxy(value)) {\n        value = (value as any)[PROXYTARGET];\n      }\n      const ok = Reflect.set(target, prop, value, receiver);\n      const handlers = handlersMap.get(targetOriginal);\n      handlers?.forEach(handler => handler(TypeEventProxyHandler.SET, [...parentPath, prop], value, objRef));\n      return ok;\n    },\n    deleteProperty(target, prop) {\n      const ok = Reflect.deleteProperty(target, prop);\n      const handlers = handlersMap.get(targetOriginal);\n      handlers?.forEach(handler => handler(TypeEventProxyHandler.UNSET, [...parentPath, prop], undefined, objRef));\n      return ok;\n    },\n    has(target, prop) {\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target) {\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    }\n  };\n}\n\nfunction createGProxy<T extends object>(\n  target: T,\n  event: EventFunctionProxyHandler,\n  objRef: any,\n  parentPath: PathProxyHandler = []\n): T {\n  if (isStaticType(target)) return target;\n  const existing = proxyCache.get(target);\n  if (existing) {\n    // sigue vivo mientras tenga handlers\n    handlersMap.get(target)!.add(event);\n    return existing.proxy;\n  }\n  // primera vez que lo vemos: creamos revocable + handler set\n  const handler = getProxyHandler(target, objRef, parentPath);\n  const { proxy, revoke } = Proxy.revocable(target, handler);\n  proxyCache.set(target, { proxy, revoke });\n  handlersMap.set(target, new Set([event]));\n  return proxy;\n}\n\nexport const GProxy = createGProxy;\n\nexport function unGProxy<T = any>(obj: T): T {\n  if (isGProxy(obj)) {\n    obj = (obj as any)[PROXYTARGET];\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(unGProxy) as any;\n  }\n  if (obj && typeof obj === 'object') {\n    const result: any = {};\n    for (const key of Reflect.ownKeys(obj)) {\n      result[key as any] = unGProxy((obj as any)[key]);\n    }\n    return result;\n  }\n  return obj;\n}\n\nexport function pathToString(path: PathProxyHandler): string {\n  return path.map(String).join('.');\n}\n\nexport function removeEventHandler(target: any, event: EventFunctionProxyHandler) {\n  if (isGProxy(target)) {\n    target = (target as any)[PROXYTARGET];\n  }\n  const handlers = handlersMap.get(target);\n  if (handlers) {\n    handlers.delete(event);\n    if (handlers.size === 0) {\n      // 1) quito tambin del mapa de handlers\n      handlersMap.delete(target);\n      // 2) revoco el proxy y luego borro la entrada en proxyCache\n      const entry = proxyCache.get(target);\n      if (entry) {\n        entry.revoke();\n        proxyCache.delete(target);\n      }\n    }\n  }\n}\n","import { BindTypes, TypeEventProxyHandler } from \"./GEnums\";\nimport { IGtplObject, IBindObject, IIndex } from \"./GGenerator\";\nimport {\n  GProxy,\n  removeEventHandler,\n  PathProxyHandler,\n  PROXYTARGET,\n  ISPROXY,\n  EventFunctionProxyHandler,\n} from \"./GProxy\";\nimport { TplVar, GAddToo, IFunction, IVarOrConst } from \"./GGenerator\";\nimport { globalObject, passiveSupported } from \"./global\";\nimport { STACK, isStaticType, log } from \"./GUtils\";\n\nexport interface IBindDef {\n  key: string;\n  val: any;\n  pro: any;\n}\n\nconst globalCache: any = {\n  binitChangeEvents: false,\n};\n\n//---\nclass privateProperties {\n  private static globalVar = new WeakMap();\n\n  static init(gtpl: IGtplObject) {\n    if (!privateProperties.globalVar.has(gtpl)) {\n      privateProperties.globalVar.set(gtpl, {\n        GenerationFinish: false,\n        MarkEle: new WeakMap(),\n        memValues: new WeakMap(),\n        renderElements: new Set(),\n      });\n    }\n  }\n\n  static getProperty(gtpl: IGtplObject, key: string) {\n    privateProperties.init(gtpl);\n    const obj = privateProperties.globalVar.get(gtpl);\n    return obj[key];\n  }\n\n  static setProperty(gtpl: IGtplObject, key: string, value: any) {\n    privateProperties.init(gtpl);\n    const obj = privateProperties.globalVar.get(gtpl);\n    obj[key] = value;\n  }\n}\n\n//---\n\ninterface IsimetricAttrValue {\n  va: Array<string>;\n  ctx: IGtplObject;\n}\n\ntype simetricAttrValueSet = Set<IsimetricAttrValue>;\n\nconst simetricAttr: WeakMap<Node, simetricAttrValueSet> = new WeakMap();\n\nfunction initChangeEvents() {\n  if (globalCache.binitChangeEvents) {\n    return;\n  }\n  try {\n    globalCache.binitChangeEvents = true;\n    const changeEvent = function (event: any) {\n      const ele: any = event.target;\n      if (simetricAttr.has(ele)) {\n        const temp = simetricAttr.get(ele);\n        if (temp) {\n          for (let obj of temp) {\n            //console.log('event', event, obj, ele);\n            updateVar(obj.va, obj.ctx, ele.value);\n          }\n        }\n      }\n    };\n    if (globalObject.addEventListener) {\n      globalObject.addEventListener(\"input\", changeEvent);\n      globalObject.addEventListener(\"change\", changeEvent);\n    }\n  } catch (ex: any) {\n    STACK(ex.message);\n  }\n}\n\n//---\n\nfunction addCheckRenderElement(gtpl: IGtplObject, bind: IBindObject) {\n  const re: Set<IBindObject> = privateProperties.getProperty(\n    gtpl,\n    \"renderElements\"\n  );\n  if (!re.has(bind)) {\n    re.add(bind);\n  }\n}\n\nfunction checkRenderElements(gtpl: IGtplObject, originalbind: IBindObject) {\n  const re: Set<IBindObject> = privateProperties.getProperty(\n    gtpl,\n    \"renderElements\"\n  );\n  if (!re.has(originalbind)) {\n    return;\n  }\n  const arr = Array.isArray(gtpl.Elements) ? gtpl.Elements : [gtpl.Elements];\n  arr.forEach((ele: Node, index: number) => {\n    const bind: IBindObject = gtpl.RenderElements[index];\n    if (bind && re.has(bind)) {\n      let allok = true;\n      if (bind.ele) {\n        const element = Array.isArray(bind.ele) ? bind.ele[0] : bind.ele;\n        if (!bind.mark.parentNode && !element.parentNode) {\n          allok = false;\n        } else if (bind.mark.parentNode && !element.parentNode) {\n          show(bind);\n          if (bind.eles) {\n            (<any>bind.eles)[0].refresh();\n            if ((<any>bind.eles)[0].refCase)\n              show((<any>bind.eles)[0].refCase);\n          }\n        }\n      } else if (bind.eles) {\n        if (bind.mark.parentNode) {\n          let marca: Node | null = null;\n          const render_arr: any = [];\n          bind.eles.forEach((gtpl: IGtplObject) => {\n            const temp: any = [];\n            gtpl.refresh();\n            gtpl.addTo(temp);\n            temp.forEach((ele: Node) => {\n              if (!ele.parentNode) {\n                render_arr.push(ele);\n              } else if (!marca) {\n                marca = ele;\n              }\n            });\n          });\n          if (render_arr.length) {\n            show(\n              {\n                type: bind.type,\n                link: bind.link,\n                ele: render_arr,\n                mark: marca ? marca : bind.mark,\n              },\n              false\n            );\n          }\n        } else {\n          allok = false;\n        }\n      }\n      if (allok) {\n        re.delete(bind);\n      }\n    }\n  });\n}\n\n//---\n\nfunction updateVar(\n  va: Array<string>,\n  ctx: IGtplObject,\n  value: any,\n  force: boolean = false\n) {\n  //console.log('updateVar', va, value, force);\n  if (va.length > 1) {\n    const reduce: any = (obj: any, index: number, fin: number) => {\n      if (index == fin) return obj[va[index]];\n      return reduce(obj[va[index]], ++index, fin);\n    };\n    const ret = reduce(ctx.Root, 0, va.length - 2);\n    const fin = va[va.length - 1];\n    if (force || ret[fin] != value) {\n      ret[fin] = value;\n    }\n  } else {\n    const fin = va[0];\n    if (force || ctx.Root[fin] != value) {\n      ctx.Root[fin] = value;\n    }\n  }\n}\n\nfunction reduceVar(\n  gtpl: IGtplObject,\n  name: string[],\n  val?: any,\n  index?: number,\n  limit?: number\n): any {\n  if (index == undefined) index = 0;\n  if (limit !== undefined && index >= name.length - limit) return val;\n  const result = val == undefined ? gtpl.getValue(name[index++]) : val[name[index++]];\n  if (limit !== undefined && index >= name.length - limit) return result;\n  if (index >= name.length) return result;\n  return reduceVar(gtpl, name, result, index);\n}\n\nasync function reduceFnc(\n  gtpl: IGtplObject,\n  functions: IFunction[],\n  index?: number,\n  initval?: any\n): Promise<any> {\n  if (index == undefined)\n    index = 0;\n  const func = functions[index];\n  const ctx = gtpl.getContext(func.name[0]);\n  const fnc: Function = reduceVar(ctx, func.name);\n  if (fnc) {\n    const arrval: any[] = [];\n    if (func.params) {\n      func.params.forEach((param: IVarOrConst) => {\n        if (param.ct != undefined)\n          arrval.push(param.ct);\n        else if (param.va != undefined)\n          arrval.push(reduceVar(gtpl, param.va));\n      });\n    }\n    if (initval != undefined)\n      arrval.push(initval);\n    initval = await fnc.apply(ctx.Root, arrval);\n  } else {\n    STACK('fnc undefined', index, functions);\n  }\n  index++;\n  if (index >= functions.length)\n    return initval;\n  return await reduceFnc(gtpl, functions, index, initval);\n}\n\n//---\n\nasync function calculateBind(me: IGtplObject, bind: IBindObject, value?: any, extraarguments?: any) {\n  let result: any = undefined;\n  const gtpl = bind.gtpl ? bind.gtpl : me;\n  if (bind.link.formula && bind.link.formula.fnc) {\n    const fnc: Function = bind.link.formula.fnc;\n    const arrval: any[] = [];\n    if (bind.link.formula.vars) {\n      const vars: TplVar[] = bind.link.formula.vars;\n      vars.forEach((key) => {\n        arrval.push(gtpl.getValue(key[0]));\n      });\n    }\n    if (extraarguments) {\n      arrval.push(extraarguments);\n    }\n    result = await fnc.apply(gtpl.Root, arrval);\n  } else {\n    if (bind.link.vorc) {\n      if (bind.link.vorc.va != undefined)\n        result = value != undefined ? value : reduceVar(gtpl, bind.link.vorc.va);\n      if (bind.link.vorc.ct != undefined) result = bind.link.vorc.ct;\n    }\n    if (bind.link.functions) {\n      result = await reduceFnc(gtpl, bind.link.functions, 0, result);\n    }\n  }\n  return result;\n}\n\n//---\n\nfunction getContext(gtpl: IGtplObject, bind: IBindObject) {\n  let ctx: IGtplObject = gtpl;\n  if (bind.link.vorc && bind.link.vorc.va) {\n    ctx = gtpl.getContext(bind.link.vorc.va[0]);\n  } else if (bind.link.functions) {\n    const fnc: IFunction = bind.link.functions[0];\n    ctx = gtpl.getContext(fnc.name[0]);\n  }\n  return ctx;\n}\n\n//---\n\nfunction createGetterAndSetter(\n  gtpl: IGtplObject,\n  va: TplVar,\n  bind: IBindObject\n) {\n  const key = va[0];\n  const ref = gtpl.BindTree[key];\n  if (ref != undefined) {\n    return;\n  }\n  const defaultvalue = gtpl.getValue(key);\n  const objdef: IBindDef = {\n    key: key,\n    val: defaultvalue, // target\n    pro: undefined, // proxy\n  };\n  gtpl.BindDef.add(objdef);\n  try {\n    if (!gtpl.Root.hasOwnProperty(key))\n      gtpl.Root[key] = null;\n    Object.defineProperty(gtpl.Root, key, {\n      get: function () {\n        if (objdef.pro !== undefined) return objdef.pro;\n        if (isStaticType(objdef.val)) return objdef.val;\n        while (objdef.val[ISPROXY]) objdef.val = objdef.val[PROXYTARGET];\n        objdef.pro = GProxy(objdef.val, gtpl.BoundEventProxy, objdef, [\n          objdef.key,\n        ]);\n        return objdef.pro;\n      },\n      set: function (newval: any) {\n        objdef.val = newval;\n        if (isStaticType(newval)) {\n          delete objdef.pro;\n          gtpl.eventPRoxy(\n            TypeEventProxyHandler.SET,\n            [objdef.key],\n            newval,\n            objdef\n          );\n          return objdef.val;\n        } else {\n          while (objdef.val[ISPROXY]) objdef.val = objdef.val[PROXYTARGET];\n          objdef.pro = GProxy(\n            objdef.val,\n            gtpl.BoundEventProxy,\n            objdef,\n            [objdef.key]\n          );\n          gtpl.eventPRoxy(\n            TypeEventProxyHandler.SET,\n            [objdef.key],\n            newval,\n            objdef\n          );\n          return objdef.pro;\n        }\n      },\n    });\n  } catch (ex) {\n    STACK((<any>ex).message, key, gtpl.Root);\n  }\n}\n\nfunction addBind2Object(gtpl: IGtplObject, va: TplVar, bind: IBindObject) {\n  let ref: any = gtpl.BindTree;\n  for (let i = 0, n = va.length; i < n; i++) {\n    const name = va[i];\n    if (i == 0) {\n      const ctx = gtpl.getContext(name);\n      createGetterAndSetter(ctx, va, bind);\n      if (ctx != gtpl) {\n        // si se aade el bind a otro contexto, hay que almacenar el contexto original\n        bind.gtpl = gtpl;\n        // almacenamos en el contexto original una referencia al contexto donde se almacena el bind\n        if (!gtpl.BindMap) gtpl.BindMap = new Map();\n        gtpl.BindMap.set(bind, ctx);\n        addBind2Object(ctx, va, bind);\n        return;\n      }\n    }\n    if (ref[name] == undefined)\n      ref[name] = {};\n    if (i < n - 1) {\n      ref = ref[name];\n      if (ref.tree == undefined) ref.tree = {};\n      ref = ref.tree;\n    } else {\n      ref = ref[name];\n    }\n  }\n  if (ref.me == undefined) {\n    ref.me = new Set();\n  }\n  ref.me.add(bind);\n}\n\nfunction getBind2Object(\n  gtpl: IGtplObject,\n  va: TplVar,\n  bind: IBindObject\n): Set<IBindObject> {\n  /*\n    if (bind.gtpl && bind.gtpl != gtpl) {\n        console.error('getBind2Object', 2);\n        const original_gtpl = bind.gtpl;\n        delete bind.gtpl;\n        return getBind2Object(original_gtpl, va, bind);\n    }\n    */\n  /*\n     if (gtpl.BindMap && gtpl.BindMap.has(bind)) {\n         console.error('getBind2Object', 1);\n         const ctx_gtpl = gtpl.BindMap.get(bind);\n         if (ctx_gtpl && ctx_gtpl != gtpl) {\n             gtpl.BindMap.delete(bind);\n             return getBind2Object(ctx_gtpl, va, bind);\n         }\n     }\n     */\n  let ref: any = gtpl.BindTree;\n  for (let i = 0, n = va.length; i < n; i++) {\n    const name = va[i];\n    if (i < n - 1) {\n      ref = ref[name];\n      ref = ref.tree;\n    } else {\n      ref = ref[name];\n    }\n  }\n  return ref.me;\n}\n\nfunction delBind(gtpl: IGtplObject, bind: IBindObject) {\n  if (bind.link.vorc && bind.link.vorc.va) {\n    getBind2Object(gtpl, bind.link.vorc.va, bind).delete(bind);\n  }\n  if (bind.link.formula?.vars) {\n    bind.link.formula.vars.forEach((va) => {\n      getBind2Object(gtpl, va, bind).delete(bind);\n    });\n  }\n  if (bind.simetric && bind.ele) {\n    const setBindings = simetricAttr.get(bind.ele);\n    if (setBindings) {\n      // Filtramos fuera todas las entradas cuyo ctx sea este GTpl\n      const nuevo = new Set(\n        Array.from(setBindings)\n          .filter(item => item.ctx !== gtpl)\n      );\n      if (nuevo.size) {\n        simetricAttr.set(bind.ele, nuevo);\n      } else {\n        simetricAttr.delete(bind.ele);\n      }\n    }\n  }\n}\n\nfunction searchBind(gtpl: IGtplObject, bind: IBindObject): boolean {\n  let encontrado = false;\n  if (bind.link.vorc && bind.link.vorc.va) {\n    if (getBind2Object(gtpl, bind.link.vorc.va, bind).has(bind))\n      encontrado = true;\n  }\n  if (bind.link.formula?.vars) {\n    bind.link.formula.vars.forEach((va) => {\n      if (getBind2Object(gtpl, va, bind).has(bind)) encontrado = true;\n    });\n  }\n  if (!encontrado) {\n    const re: Set<IBindObject> = privateProperties.getProperty(\n      gtpl,\n      \"renderElements\"\n    );\n    if (re.has(bind)) re.delete(bind);\n  }\n  return encontrado;\n}\n\n//---\n\nfunction checkBindVar(gtpl: IGtplObject, bind: IBindObject): boolean {\n  if (bind.type == BindTypes.VAR) {\n    //log('checkBindVar', gtpl, bind);\n    if (bind.link.svar && bind.link.vorc && bind.link.vorc.va) {\n      const temp = bind.link.vorc.va.join(\"\");\n      if (temp == \"this\") {\n        bind.ele[bind.link.svar] = gtpl.Root;\n      } else {\n        bind.ele[bind.link.svar] = reduceVar(gtpl, bind.link.vorc.va);\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction checkBindEvent(gtpl: IGtplObject, bind: IBindObject): boolean {\n  if (bind.type == BindTypes.EVENT && bind.prop) {\n    //log('checkBindEvent', gtpl, bind);\n    const ctx: IGtplObject = getContext(gtpl, bind);\n    const obj = { gtpl: ctx, bind: bind };\n    const options: any = { passive: false };\n    if ([\"wheel\", \"mousewheel\", \"touchstart\", \"touchmove\"].includes(bind.prop.toLowerCase()))\n      options.passive = true;\n    bind.ele.addEventListener(\n      bind.prop,\n      async function (event: any) {\n        const result = await calculateBind(obj.gtpl, obj.bind, undefined, event);\n        //console.error(result, obj.bind, event);\n        if (typeof result == \"function\") {\n          if (obj.bind.link.params) {\n            const arrval: any = [];\n            obj.bind.link.params.forEach((param) => {\n              if (param.ct != undefined) arrval.push(param.ct);\n              else if (param.va != undefined)\n                arrval.push(reduceVar(gtpl, param.va));\n            });\n            result.apply(obj.gtpl.Root, [event, ...arrval]);\n          } else {\n            result.apply(obj.gtpl.Root, [event]);\n          }\n        } else {\n          if (result === false) {\n            if (event.preventDefault)\n              event.preventDefault();\n            if (event.stopPropagation)\n              event.stopPropagation();\n          }\n        }\n      },\n      passiveSupported ? options : false\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkBindFormula(gtpl: IGtplObject, bind: IBindObject): boolean {\n  let result = false;\n  if (bind.link.formula && bind.link.formula.vars && bind.link.formula.vars.length) {\n    result = true;\n    bind.link.formula.vars.forEach((va) => {\n      addBind2Object(gtpl, va, bind);\n    });\n  }\n  return result;\n}\n\nfunction checkSimetricBind(gtpl: IGtplObject, bind: IBindObject) {\n  if (\n    bind.type == BindTypes.ATTR &&\n    bind.prop &&\n    bind.link &&\n    bind.link.vorc &&\n    bind.link.vorc.va\n  ) {\n    const { prop } = bind;\n    if (prop.startsWith('[') && prop.endsWith(']')) {\n      //---\n      initChangeEvents();\n      //---\n      bind.simetric = true;\n      bind.prop = prop.slice(1, - 1);\n      //---\n      const va = bind.link.vorc.va;\n      const ctx: any = gtpl.getContext(va[0]);\n      //---\n      if (bind.prop == \"value\") {\n        if (!simetricAttr.has(bind.ele)) simetricAttr.set(bind.ele, new Set());\n        simetricAttr.get(bind.ele)?.add({\n          va: va,\n          ctx: ctx,\n        });\n      }\n      //---\n      if (bind.prop in bind.ele.constructor.prototype) {\n        const original: any = Object.getOwnPropertyDescriptor(\n          bind.ele.constructor.prototype,\n          bind.prop\n        );\n        if (original) {\n          Object.defineProperty(bind.ele, bind.prop, {\n            get: function () {\n              //console.log('get', bind, this, original.get.call(this));\n              return original.get.call(this);\n            },\n            set: function (value) {\n              //console.log('set', bind, this, value);\n              if (\n                bind.prop == \"value\" &&\n                bind.ele.nodeName.toLowerCase() == \"select\"\n              ) {\n                const ret = original.set.call(this, value);\n                if (original.get.call(this) == value)\n                  updateVar(va, ctx, value);\n                else log(\"select value not valid\", value + ' not in options');\n                return ret;\n              } else {\n                updateVar(va, ctx, value);\n                return original.set.call(this, value);\n              }\n            },\n          });\n        } else {\n          log(\n            \"simetric attr error\",\n            bind.prop,\n            \" not in \",\n            bind.ele.constructor.prototype\n          );\n        }\n      } else {\n        log(\"simetric attr error\", bind.prop, \" in \", bind.ele);\n      }\n      //---\n    }\n  }\n}\n\nfunction checkBind(gtpl: IGtplObject, bind: IBindObject): boolean {\n  let result = false;\n  if (bind.link.vorc && bind.link.vorc.va) {\n    result = true;\n    checkSimetricBind(gtpl, bind);\n    addBind2Object(gtpl, bind.link.vorc.va, bind);\n  }\n  if (bind.link.functions) {\n    bind.link.functions.forEach((fnc: IFunction) => {\n      if (fnc.params) {\n        fnc.params.forEach((param: IVarOrConst) => {\n          if (param.va) {\n            result = true;\n            addBind2Object(gtpl, param.va, bind);\n          }\n        });\n      }\n    });\n  }\n  return result;\n}\n\n//---\n\nfunction removeElements(elements: any) {\n  if (Array.isArray(elements)) {\n    elements.forEach((element) => {\n      if (element.destroy)\n        element.destroy(true);\n      else removeElements(element);\n    });\n  } else {\n    if (elements.destroy)\n      elements.destroy(true);\n    else elements.parentNode?.removeChild(elements);\n  }\n}\n\n//---\n\nfunction iterBind(\n  btree: any,\n  type: TypeEventProxyHandler,\n  path: string[],\n  value?: any,\n  arr: any[] = [],\n  depth: number = 0,            // posicin actual en `path`\n): any[] {\n  if (!btree) return arr;\n  // 1) Procesar los binds en este nodo\n  if (btree.me) {\n    btree.me.forEach((bind: IBindObject) => {\n      // Para los binds en la raz (depth=0) pasamos el `value`, \n      // en niveles inferiores slo pasamos `undefined`\n      const bindValue = (depth === 0 ? value : undefined);\n      // Copiamos slo el trozo relevante de `path` a partir de `depth`\n      const subPath = path.slice(depth);\n      arr.push([type, bind, subPath, bindValue]);\n    });\n  }\n  // 2) Recorrer subrboles\n  if (btree.tree) {\n    const keyAtDepth = path[depth];\n    for (const key in btree.tree) {\n      // Si no hay path (depth >= path.length) o coincide la clave, continuamos\n      if (keyAtDepth === undefined || keyAtDepth === key) {\n        // Calculamos el nuevo `value` para la rama:\n        const nextValue =\n          value !== undefined\n            ? (keyAtDepth === undefined ? value : (value as any)[key])\n            : undefined;\n        // Llamada recursiva incrementando `depth`\n        iterBind(\n          btree.tree[key],\n          type,\n          path,\n          nextValue,\n          arr,\n          depth + 1\n        );\n      }\n    }\n  }\n  return arr;\n}\n\n//---\n\nfunction checkMarkEle(gtpl: IGtplObject, bind: IBindObject, bresult: boolean) {\n  // si hay varios tipos de bindados a un mismo elemento, if + switch por ejemplo\n  // hay que hacer que solo se genere en una ocasin, y el otro coja los elementos\n  // generados por el que primero llegue.\n  if (bresult) {\n    const MarkEle = privateProperties.getProperty(gtpl, \"MarkEle\");\n    const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n    if (!bind.ele) {\n      if (bind.mark) {\n        if (bind.gen) {\n          if (MarkEle.has(bind.mark)) {\n            bind.ele = MarkEle.get(bind.mark);\n          } else {\n            bind.ele = (<Function>bind.gen)(bind.gtpl ? bind.gtpl : gtpl);\n            MarkEle.set(bind.mark, bind.ele);\n          }\n          delete bind.gen;\n        } else {\n          if (MarkEle.has(bind.mark)) {\n            bind.ele = MarkEle.get(bind.mark);\n            memValues.delete(bind);\n          }\n        }\n      }\n    } else if (MarkEle.has(bind.mark)) {\n      if (bind.ele != MarkEle.get(bind.mark)) {\n        bind.ele = MarkEle.get(bind.mark);\n        memValues.delete(bind);\n      }\n    }\n  }\n}\n\nfunction checkMarkRender(bind: IBindObject) {\n  let allok = true;\n  if (bind.mark.checks) {\n    for (let i in bind.mark.checks) {\n      if (!bind.mark.checks[i]) {\n        allok = false;\n        break;\n      }\n    }\n  }\n  return allok;\n}\n\n/*\nfunction checkValSelect(parentElement: HTMLElement, childElement: HTMLElement) {\n    try {\n        if (parentElement.nodeName && parentElement.nodeName.toLowerCase() == 'select' &&\n            childElement.nodeName && childElement.nodeName.toLowerCase() == 'option') {\n            console.log('checkValSelect', parentElement, childElement);\n            if ((parentElement as HTMLSelectElement).value !== '' &&\n                (parentElement as HTMLSelectElement).value === (childElement as HTMLOptionElement).value) {\n                (childElement as HTMLOptionElement).selected = true;\n            }\n        }\n    } catch (ex) { console.error(ex); }\n}\n*/\n\nfunction show(bind: IBindObject, remove: boolean = true) {\n  if (bind.ele) {\n    if (Array.isArray(bind.ele)) {\n      bind.ele.forEach((ele) => {\n        bind.mark.parentNode.insertBefore(ele, bind.mark);\n        //checkValSelect(bind.mark.parentNode, ele);\n      });\n    } else {\n      bind.mark.parentNode.insertBefore(bind.ele, bind.mark);\n      //checkValSelect(bind.mark.parentNode, bind.ele);\n    }\n    if (remove) bind.mark.remove();\n  }\n}\n\nfunction hide(bind: IBindObject, insert: boolean = true) {\n  if (bind.ele) {\n    if (Array.isArray(bind.ele)) {\n      if (insert) bind.ele[0].parentNode.insertBefore(bind.mark, bind.ele[0]);\n      bind.ele.forEach((ele) => {\n        ele.remove();\n      });\n    } else {\n      if (insert) bind.ele.parentNode.insertBefore(bind.mark, bind.ele);\n      bind.ele.remove();\n    }\n  }\n}\n\nfunction renderBind(gtpl: IGtplObject, bind: IBindObject, render: boolean) {\n  const index = getElementIndex(gtpl, bind);\n  const canrender = checkMarkRender(bind);\n  if (render && canrender) {\n    if (index >= 0) gtpl.RenderElements[index] = bind;\n    if (bind.mark.parentNode) show(bind);\n    else if (index >= 0 && searchBind(gtpl, bind))\n      addCheckRenderElement(gtpl, bind);\n  } else {\n    if (index >= 0) delete gtpl.RenderElements[index];\n    if (bind.ele.parentNode) hide(bind);\n    else if (index >= 0 && searchBind(gtpl, bind))\n      addCheckRenderElement(gtpl, bind);\n  }\n  if (render && !canrender) return false;\n  return true;\n}\n\nfunction getElementIndex(gtpl: IGtplObject, bind: IBindObject) {\n  // si la marca se encuentra en el array de elementos, quiere decir que su padre\n  // es el padre de la marca, si va ser un elemento del dom puede existir posibilidad\n  // de que el parentelement de la marca an no exista, en ese caso, tenemos el array\n  // renderelements donde pondremos los elementos a renderizar en el mismo nivel que su marca\n  const index = gtpl.Elements.indexOf(bind.mark);\n  if (index >= 0) {\n    if (!gtpl.RenderElements) {\n      //gtpl.RenderElements = Array(gtpl.Elements.length).fill(null);\n      gtpl.RenderElements = {};\n    }\n  }\n  return index;\n}\n\nfunction createGTpl(\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  objindex?: IIndex,\n  elementos?: IGtplObject[],\n  row?: any,\n  refresh?: boolean /*, objparent: any*/\n) {\n  const options: any = {\n    parent: bind.gtpl ? bind.gtpl : gtpl,\n    generator: bind.gen,\n  };\n  if (objindex && elementos && row) {\n    const obj: any = {};\n    obj[objindex.index] = elementos.length;\n    obj[objindex.target] = row;\n    //obj[SPARENT] = objparent;\n    options.context = [objindex.index, objindex.target];\n    options.root = obj;\n  }\n  if (refresh !== undefined) {\n    options.refresh = refresh;\n  }\n  return new GTpl(options);\n}\n\n//---\n\nasync function updateTEXTbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('TEXT', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (result !== undefined && result !== null) {\n    if (memValues.has(bind) && memValues.get(bind) == result) {\n      return gtpl;\n    }\n    memValues.set(bind, result);\n  }\n  //---\n  bind.ele.textContent = result;\n  //---\n  return gtpl;\n}\n\nasync function updateATTRbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  gtpl = getContext(gtpl, bind);\n  const updateProperty = (prop: string, value: any) => {\n    if (bind.ele[prop] !== undefined && bind.ele[prop] !== null) {\n      if (value === undefined || value === null) {\n        if (bind.ele[prop] !== \"\")\n          bind.ele[prop] = null;\n      } else if (bind.ele[prop] != value) {\n        try {\n          bind.ele[prop] = value;\n        } catch (ex) {\n          STACK((<any>ex).message, bind.ele, prop);\n        }\n      }\n    } else {\n      if (value === undefined || value === null) {\n        bind.ele.removeAttribute(prop);\n      } else if (bind.ele.getAttribute(prop) != value) {\n        bind.ele.setAttribute(prop, value);\n      }\n    }\n  };\n  if (bind.prop) {\n    updateProperty(bind.prop, result);\n  } else {\n    if (result === undefined || result === null) {\n      if (bind.attrs) {\n        bind.attrs.forEach((key) => {\n          updateProperty(key, null);\n        });\n        delete bind.attrs;\n      }\n    } else {\n      if (!bind.attrs)\n        bind.attrs = [];\n      const missing = bind.attrs.filter(key => !(key in result));\n      missing.forEach((key) => {\n        updateProperty(key, null);\n      });\n      bind.attrs.length = 0;\n      for (let key in result) {\n        bind.attrs.push(key);\n        updateProperty(key, result[key]);\n      }\n    }\n  }\n  return gtpl;\n}\n\nasync function updateINNERbind(type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  gtpl = getContext(gtpl, bind);\n  if (result !== undefined && bind.ele.innerHTML != result)\n    bind.ele.innerHTML = result;\n  return gtpl;\n}\n\nasync function updateSTYLEbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('STYLE', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) == result) return gtpl;\n  memValues.set(bind, result);\n  //---\n  if (bind.prop) {\n    bind.ele.style[bind.prop] = result;\n  }\n  //---\n  return gtpl;\n}\n\nasync function updateIFbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('IF/NOTIF', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const bresult = bind.type == BindTypes.NOTIF ? !result : !!result;\n  //---\n  if (!bind.mark.checks) bind.mark.checks = {};\n  bind.mark.checks[bind.type] = bresult;\n  //---\n  checkMarkEle(gtpl, bind, bresult);\n  //---\n  if (!bind.ele) {\n    return gtpl;\n  }\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) === bresult) return gtpl;\n  //---\n  if (renderBind(gtpl, bind, bresult)) memValues.set(bind, bresult);\n  //---\n  return gtpl;\n}\n\nasync function updateFORbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //console.log('FOR', type, bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  //if (!searchBind(gtpl, bind)) {\n  //    return;\n  //}\n  //---\n  if (!bind.eles) bind.eles = [];\n  //---\n  const elementos = bind.eles;\n  const objindex: IIndex = <IIndex>bind.link.index;\n  //---\n  const render_arr: any = [];\n  const delete_arr: any = [];\n  //---\n  const index: any = (Array.isArray(path) && path.length) ? path[0] : undefined;\n  //---\n  if (!isNaN(index)) {\n    const ppath: any = path;\n    if (type == TypeEventProxyHandler.SET) {\n      let update = false;\n      if (ppath.length > 1) {\n        update = true;\n      } else if (ppath.length == 1 && elementos.length == result.length) {\n        const newgtpl = elementos[index];\n        newgtpl.Root[objindex.target] = result[index];\n        return gtpl;\n      }\n      if (update) {\n        const newgtpl = elementos[index];\n        ppath.shift();\n        updateVar(\n          ppath,\n          <any>{ Root: newgtpl.Root[objindex.target] },\n          reduceVar(gtpl, ppath, result[index]),\n          true\n        );\n      } else {\n        const newgtpl = createGTpl(\n          gtpl,\n          bind,\n          objindex,\n          elementos,\n          result[index],\n          false\n        );\n        elementos.push(newgtpl);\n        render_arr.push([newgtpl, index]);\n      }\n    }\n    if (type == TypeEventProxyHandler.UNSET) {\n      if (ppath.length > 1) {\n        const newgtpl = elementos[index];\n        newgtpl.Root[objindex.target] = result[index];\n      } else {\n        const newgtpl: IGtplObject = elementos.splice(index, 1)[0];\n        delete_arr.push([newgtpl, index]);\n      }\n    }\n  } else if (result && result.length) {\n    if (index == 'length' && elementos.length == result.length)\n      return gtpl;\n    result.forEach((row: any, index: number) => {\n      if (index >= elementos.length) {\n        const newgtpl = createGTpl(\n          gtpl,\n          bind,\n          objindex,\n          elementos,\n          row,\n          false /*, result*/\n        );\n        elementos.push(newgtpl);\n        render_arr.push([newgtpl, index]);\n      } else {\n        const obj: any = elementos[index].Root;\n        obj[objindex.target] = row;\n      }\n    });\n    if (elementos.length > result.length) {\n      const gtpls = elementos.splice(\n        result.length,\n        elementos.length - result.length\n      );\n      gtpls.forEach((newgtpl, index: number) => {\n        delete_arr.push([newgtpl, index]);\n      });\n    }\n  } else if (elementos.length) {\n    elementos.forEach((newgtpl, index: number) => {\n      delete_arr.push([newgtpl, index]);\n    });\n    elementos.length = 0;\n  }\n  //---\n  if (delete_arr.length) {\n    delete_arr.forEach((rowinfo: any) => {\n      const [newgtpl, index] = rowinfo;\n      newgtpl.destroy();\n      gtpl.GtplChilds.delete(newgtpl);\n    });\n  }\n  //---\n  if (render_arr.length) {\n    //---\n    const renderindex = getElementIndex(gtpl, bind);\n    if (renderindex >= 0) {\n      if (!gtpl.RenderElements[renderindex]) {\n        gtpl.RenderElements[renderindex] = bind;\n      }\n    }\n    //---\n    const all: any = [];\n    render_arr.forEach((rowinfo: any) => {\n      const [newgtpl, index] = rowinfo;\n      newgtpl.addTo(all);\n      gtpl.GtplChilds.add(newgtpl);\n    });\n    //---\n    if (bind.mark.parentNode) {\n      //---\n      show(\n        {\n          type: bind.type,\n          link: bind.link,\n          ele: all,\n          mark: bind.mark,\n        },\n        false\n      );\n      //---\n      render_arr.forEach((rowinfo: any) => {\n        rowinfo[0].refresh();\n      });\n      //---\n    } else if (renderindex >= 0 && searchBind(gtpl, bind)) {\n      addCheckRenderElement(gtpl, bind);\n    }\n    //---\n  }\n  //---\n  return gtpl;\n}\n\nasync function updateSWITCHbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('SWITCH', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const bresult = result !== undefined && result !== null ? true : false;\n  //---\n  if (!bind.mark.checks) bind.mark.checks = {};\n  bind.mark.checks[bind.type] = bresult;\n  //---\n  checkMarkEle(gtpl, bind, bresult);\n  //---\n  if (!bind.mark.checks) bind.mark.checks = {};\n  bind.mark.checks[bind.type] = result == undefined ? false : true;\n  //---\n  if (!bind.ele) {\n    return gtpl;\n  }\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) === result) {\n    return gtpl;\n  }\n  memValues.set(bind, result);\n  //---\n  if (bind.case && bind.case.length) {\n    //---\n    if (bind.eles && bind.eles.length) {\n      bind.eles.forEach((gtplcase: IGtplObject) => {\n        hide((<any>gtplcase).refCase);\n        gtplcase.destroy();\n        gtpl.GtplChilds.delete(gtplcase);\n      });\n      delete bind.eles;\n    }\n    //---\n    if (!searchBind(gtpl, bind)) {\n      return gtpl;\n    }\n    //---\n    if (bresult) {\n      //---\n      if (!bind.case[0].mark) {\n        //---\n        const mcobj: any = {};\n        //---\n        for (let i = 0, n = bind.ele.childNodes.length; i < n; i++) {\n          const node = bind.ele.childNodes[i];\n          if (node.nodeType === 8) {\n            if (node.textContent.length == 6) {\n              mcobj[node.textContent] = node;\n            }\n          }\n        }\n        //---\n        for (let i = 0, n = bind.case.length; i < n; i++) {\n          const ca = bind.case[i];\n          if (!ca.mark && ca.uid) {\n            ca.mark = mcobj[ca.uid];\n          }\n        }\n        //---\n      }\n      //---\n      for (let i = 0, n = bind.case.length; i < n; i++) {\n        const ca = bind.case[i];\n        const valca = await calculateBind(gtpl, ca);\n        if (valca == result) {\n          const gtplcase = createGTpl(\n            gtpl,\n            ca,\n            undefined,\n            undefined,\n            undefined,\n            false\n          );\n          ca.ele = gtplcase.Elements;\n          ca.eles = [gtplcase];\n          (<any>gtplcase).refCase = ca;\n          gtpl.GtplChilds.add(gtplcase);\n          //console.error('GtplChilds', gtpl.GtplChilds.size);\n          bind.eles = ca.eles;\n          break;\n        }\n      }\n      //---\n    }\n    //---\n  }\n  //---\n  if (renderBind(gtpl, bind, bresult)) {\n    if (bresult) {\n      (<any>bind.eles)[0].refresh();\n      show((<any>bind.eles)[0].refCase);\n    }\n  }\n  //---\n  return gtpl;\n}\n\nasync function updateISbind(\n  type: TypeEventProxyHandler,\n  gtpl: IGtplObject,\n  bind: IBindObject,\n  result?: any,\n  path?: string[]\n) {\n  //log('IS', bind, result, path);\n  //---\n  gtpl = getContext(gtpl, bind);\n  //---\n  const bresult = result !== undefined && result !== null ? true : false;\n  //---\n  const memValues = privateProperties.getProperty(gtpl, \"memValues\");\n  if (memValues.has(bind) && memValues.get(bind) == result) return gtpl;\n  memValues.set(bind, result);\n  //---\n  let check = false;\n  if (bind.eles) {\n    check = true;\n    bind.eles[0].destroy();\n    gtpl.GtplChilds.delete(bind.eles[0]);\n    delete bind.eles;\n  } else if (bind.ele) {\n    hide(bind);\n  }\n  //---\n  if (!bresult) return gtpl;\n  //---\n  if (check && !searchBind(gtpl, bind)) {\n    return gtpl;\n  }\n  //---\n  if (Array.isArray(result) || typeof result == \"function\") {\n    const newgtpl = createGTpl(gtpl, {\n      link: bind.link,\n      type: bind.type,\n      gtpl: bind.gtpl,\n      gen: result,\n    });\n    bind.eles = [newgtpl];\n    gtpl.GtplChilds.add(newgtpl);\n    bind.ele = newgtpl.Elements;\n  } else {\n    bind.ele = result;\n  }\n  //---\n  privateProperties.getProperty(gtpl, \"MarkEle\").set(bind.mark, bind.ele);\n  //---\n  renderBind(gtpl, bind, bresult);\n  //---\n  return gtpl;\n}\n\n//---\n\nexport class GTpl implements IGtplObject {\n  ID!: string;\n\n  /**\n   * Referencia a la funcin generadora.\n   */\n  FncElements!: Function | Array<any>;\n\n  /**\n   * Array de array de elementos html que forman la plantilla\n   */\n  Elements!: Node[];\n\n  /**\n   * Objeto indexado a los elementos dinamicos de ka plantillas, for, switch etc...\n   */\n  RenderElements!: any;\n\n  /**\n   * Es el arbol de objetos bindados siguiendo la misma ramificacin que en el arbol html.\n   */\n  BindTree!: any;\n\n  /**\n   * Son los objetos bindados con constantes, no dinmicos.\n   */\n  BindConst!: Set<IBindObject>;\n\n  /**\n   * Mapa de objetos bindados a plantillas diferentes a la original.\n   * Por ejemplo: cuando se tiene una plantilla dentro de otra plantilla.\n   */\n  BindMap!: Map<IBindObject, IGtplObject>;\n\n  /**\n   * Son las claves de primer nivel de objetos bindados a la plantilla.\n   */\n  BindDef!: Set<IBindDef>;\n\n  /**\n   * Plantillas hijas.\n   */\n  GtplChilds!: Set<IGtplObject>;\n\n  /**\n   * Plantilla padre.\n   */\n  Parent!: IGtplObject;\n\n  /**\n   * Utilizado para localizar el contexto de la variable que se solicita.\n   */\n  Context!: Set<String>;\n\n  /**\n   * Objeto referencia para aplicar a la plantilla.\n   */\n  Root: any;\n\n  BoundEventProxy: EventFunctionProxyHandler;\n\n  constructor(options?: any) {\n    //log('constructor', this, options);\n    this.ID = Math.random().toString(16).slice(2);\n    this.BindTree = {};\n    this.BindConst = new Set();\n    this.BindDef = new Set();\n    this.GtplChilds = new Set();\n    this.BoundEventProxy = this.eventPRoxy.bind(this);\n    this.loadOptions(options);\n  }\n\n  loadOptions(options?: any) {\n    if (options) {\n      this.Root = options.root;\n      if (options.parent) this.Parent = options.parent;\n      if (options.context) this.Context = new Set(options.context);\n      if (options.generator) {\n        this.FncElements = options.generator;\n        this.Elements = [];\n        GAddToo(this.Elements, this.FncElements, this);\n      }\n      privateProperties.setProperty(this, \"GenerationFinish\", true);\n      if (options.refresh === undefined || options.refresh === true)\n        this.refresh();\n    }\n  }\n\n  getValue(key: any): any {\n    const ref = this.Root;\n    if (ref) {\n      if (ref.hasOwnProperty(key)) return ref[key];\n      if (ref[key] !== undefined) return ref[key];\n    }\n    if (this.Parent) return this.Parent.getValue(key);\n    return undefined;\n  }\n\n  getGtplRoot(): GTpl {\n    if (this.Parent) return this.Parent.getGtplRoot();\n    return this;\n  }\n\n  getRoot(): any {\n    if (this.Parent) return this.Parent.getRoot();\n    return this.Root;\n  }\n\n  getContext(key: string): GTpl {\n    if (this.Context && this.Context.has(key)) return this;\n    if (this.Parent) return this.Parent.getContext(key);\n    return this.getGtplRoot();\n  }\n\n  addBind(bind: IBindObject) {\n    //log('addBind', this, bind);\n    if (!checkBindVar(this, bind))\n      if (!checkBindEvent(this, bind))\n        if (!checkBindFormula(this, bind))\n          if (!checkBind(this, bind))\n            this.BindConst.add(bind);\n    if (privateProperties.getProperty(this, \"GenerationFinish\")) {\n      this.launchChange(TypeEventProxyHandler.UKNOW4, bind);\n    }\n  }\n\n  destroy(elements = true) {\n    this.GtplChilds.forEach(child => child.destroy(false));\n    this.GtplChilds.clear();\n    if (this.BindDef) {\n      for (const objdef of this.BindDef) {\n        removeEventHandler(objdef.val, this.BoundEventProxy);\n      }\n      this.BindDef.clear();\n    }\n    if (this.BindMap) {\n      for (const [bind, ctxgtpl] of this.BindMap) {\n        delBind(ctxgtpl, bind);\n      }\n      this.BindMap.clear();\n    }\n    if (elements) {\n      removeElements(this.Elements);\n      if (this.RenderElements) {\n        const entries = Array.isArray(this.Elements) ? this.Elements.length : 1;\n        for (let index = 0; index < entries; index++) {\n          const bind: IBindObject = this.RenderElements[index];\n          if (bind) {\n            if (bind.ele) removeElements(bind.ele);\n            if (bind.eles) removeElements(bind.eles);\n          }\n        }\n        this.RenderElements = null;\n      }\n    }\n    // Cleanup total\n    this.Elements = null!;\n    this.Root = null!;\n    this.BindTree = null!;\n    this.BindConst = null!;\n    this.Context = null!;\n    this.Parent = null!;\n  }\n\n  refresh() {\n    for (let objdef of this.BindDef) {\n      this.eventPRoxy(TypeEventProxyHandler.UKNOW4, [], undefined, objdef);\n    }\n    if (this.BindMap) {\n      for (let [bind, gtpl] of this.BindMap) {\n        gtpl.launchChange(TypeEventProxyHandler.UKNOW5, bind);\n      }\n    }\n    if (this.BindConst) {\n      for (let bind of this.BindConst) {\n        this.launchChange(TypeEventProxyHandler.UKNOW6, bind);\n      }\n    }\n  }\n\n  addTo(ele: Node | any[]) {\n    //console.log('addTo', ele);\n    if (this.RenderElements) {\n      const render_arr: any = [];\n      const arr = Array.isArray(this.Elements)\n        ? this.Elements\n        : [this.Elements];\n      arr.forEach((ele: Node, index: number) => {\n        if (this.RenderElements[index]) {\n          const bind: IBindObject = this.RenderElements[index];\n          if (bind.ele) {\n            render_arr.push(bind.ele);\n          } else if (bind.eles) {\n            bind.eles.forEach((gtpl: IGtplObject) => gtpl.addTo(render_arr));\n            render_arr.push(bind.mark);\n          }\n        } else {\n          render_arr.push(ele);\n        }\n      });\n      GAddToo(ele, render_arr, this);\n    } else {\n      GAddToo(ele, this.Elements, this);\n    }\n  }\n\n  eventPRoxy(\n    type: TypeEventProxyHandler,\n    path: PathProxyHandler,\n    value: any,\n    objRef: any\n  ) {\n    //log('eventPRoxy', 'event:', type, 'path:', path, 'value:', value, 'objref:', objRef);\n    const pa = path;\n    pa?.shift();\n    iterBind(this.BindTree[objRef.key], type, path, value, [], 1).forEach((args: any) =>\n      this.launchChange.apply(this, args)\n    );\n  }\n\n  async launchChange(\n    type: TypeEventProxyHandler,\n    bind: IBindObject,\n    path?: string[],\n    value?: any\n  ) {\n    //log('launchChange' /*, type, bind, path, value*/ );\n    if (BindTypes.EVENT == bind.type)\n      return;\n    const result = await calculateBind(this, bind, value);\n    let gtpl: IGtplObject = this;\n    switch (bind.type) {\n      case BindTypes.TEXT:\n        gtpl = await updateTEXTbind(type, this, bind, result, path);\n        break;\n      case BindTypes.ATTR:\n        gtpl = await updateATTRbind(type, this, bind, result, path);\n        break;\n      case BindTypes.INNER:\n        gtpl = await updateINNERbind(type, this, bind, result, path);\n        break;\n      case BindTypes.STYLE:\n        gtpl = await updateSTYLEbind(type, this, bind, result, path);\n        break;\n      case BindTypes.IF:\n      case BindTypes.NOTIF:\n        gtpl = await updateIFbind(type, this, bind, result, path);\n        break;\n      case BindTypes.FOR:\n        gtpl = await updateFORbind(type, this, bind, result, path);\n        break;\n      case BindTypes.SWITCH:\n        gtpl = await updateSWITCHbind(type, this, bind, result, path);\n        break;\n      case BindTypes.IS:\n        gtpl = await updateISbind(type, this, bind, result, path);\n        break;\n    }\n    checkRenderElements(gtpl, bind);\n  }\n}\n","import { BindTypes, TypeEventProxyHandler } from './GEnums';\nimport { EventFunctionProxyHandler } from './GProxy';\nimport { globalObject } from './global';\nexport interface IVarOrConst {\n    va?: null | TplVar,\n    ct?: null | string\n}\n\nexport interface IFunction {\n    name: TplVar,\n    params?: IVarOrConst[]\n}\n\nexport interface IIndex {\n    index: string,\n    target: string\n}\n\nexport interface IFormula {\n    code?: string,\n    vars?: TplVar[],\n    fnc?: Function\n}\n\nexport interface IObjParsed {\n    vorc?: IVarOrConst,\n    svar?: string,\n    functions?: IFunction[],\n    index?: IIndex,\n    formula?: IFormula,\n    params?: IVarOrConst[]\n}\n\nexport interface IGtplObject {\n    refresh(): unknown;\n    ID?: string,\n    Root: any,\n    Elements: any,\n    RenderElements?: any,\n    GtplChilds: Set<IGtplObject>,\n    BindMap: Map<IBindObject, IGtplObject>,\n    BindTree: any;\n    BindDef: any,\n    addBind: Function,\n    getContext: Function,\n    getValue: Function,\n    getRoot: Function,\n    getGtplRoot: Function,\n    destroy: Function,\n    eventPRoxy: Function,\n    addTo: Function,\n    launchChange: Function,\n    BoundEventProxy: EventFunctionProxyHandler\n}\n\nexport interface IBindObject {\n    type: BindTypes,\n    prop?: string,\n    link: IObjParsed,\n    index?: number,\n    case?: IBindObject[],\n    gen?: ProGen,\n    uid?: string,\n    common?: any,\n    ele?: any,\n    mark?: any,\n    eles?: IGtplObject[],\n    gtpl?: IGtplObject,\n    simetric?: boolean,\n    attrs?: string[]\n}\n\n//---\n\nexport type AttrType = (string | IBindObject | string[]);\n\nexport type ProGen = string | Function;\n\nexport type TplVar = string[];\n\n//---\n\nfunction bindNode(bind: IBindObject, node?: Node, mark?: Node) {\n    if (mark)\n        bind.mark = mark;\n    if (node)\n        bind.ele = node;\n    return bind;\n}\n\nfunction appendChildsFromFnc(ele: Node | any[], childs: Node | Function | any[], objRoot: IGtplObject) {\n    //console.log('appendChildsFromFnc', ele, childs, objRoot);\n    if (Array.isArray(childs)) {\n        childs.forEach((child: any) => {\n            appendChildsFromFnc(ele, child, objRoot);\n        });\n    } else if (typeof childs == 'function') {\n        appendChildsFromFnc(ele, childs(objRoot), objRoot);\n    } else if (childs !== null && childs !== undefined) {\n        if (Array.isArray(ele)) {\n            ele.push(childs);\n        } else {\n            ele.appendChild(childs);\n            /*\n            try {\n                if (ele.nodeName && ele.nodeName.toLowerCase() == 'select' &&\n                    childs.nodeName && childs.nodeName.toLowerCase() == 'option') {\n                    if ((ele as HTMLSelectElement).value !== '' &&\n                        (ele as HTMLSelectElement).value === (childs as HTMLOptionElement).value) {\n                        (childs as HTMLOptionElement).selected = true;\n                    }\n                }\n            } catch (ex) { console.error(ex); }\n            */\n        }\n    }\n}\n\nfunction createElement(nodeName: string, attributes: AttrType[], fncChilds: Function, objRoot: IGtplObject) {\n    //console.log('createElement', nodeName, attributes, fncChilds, objRoot);\n    let tempvar: any = null;\n    switch (nodeName) {\n        case '#text':\n            if (tempvar == null)\n                tempvar = globalObject.document.createTextNode('');\n            if (typeof attributes == 'string')\n                tempvar.textContent = attributes;\n        case '#comment':\n            if (tempvar == null)\n                tempvar = globalObject.document.createComment('');\n            if (typeof attributes == 'string') {\n                tempvar.textContent = attributes;\n            } else {\n                attributes.forEach((attr) => {\n                    if (typeof attr == 'string') {\n                        tempvar.textContent = attr;\n                        return;\n                    }\n                    if (Array.isArray(attr)) {\n                        console.error(tempvar, attr);\n                        return;\n                    }\n                    if (attr.type == BindTypes.TEXT)\n                        objRoot.addBind(bindNode(<IBindObject>attr, tempvar));\n                    else objRoot.addBind(bindNode(<IBindObject>attr, undefined, tempvar));\n                });\n            }\n            return tempvar;\n        default:\n            const ele = globalObject.document.createElement(nodeName);\n            appendChildsFromFnc(ele, fncChilds, objRoot);\n            if (Array.isArray(attributes)) {\n                attributes.forEach((attr) => {\n                    if (Array.isArray(attr)) {\n                        ele.setAttribute(attr[0], attr[1]);\n                    } else {\n                        const bind: IBindObject = <IBindObject>attr;\n                        objRoot.addBind(bindNode(bind, ele));\n                    }\n                });\n            }\n            return ele;\n    }\n}\n\nfunction compile(gcode: string, ggenerator?: any): any {\n    return new Function('g', `return ${gcode};`)(ggenerator ? ggenerator : createElement);\n}\n\nexport const GGenerator = createElement;\n\nexport const GAddToo = appendChildsFromFnc;\n\nexport const GCompile = compile;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nimport { GTpl } from \"../GTpl\";\nimport { GGenerator, GCompile, GAddToo } from \"../GGenerator\";\nimport { STACK, css2obj, style2css } from \"../GUtils\";\nimport { GCode } from \"../compiler/GCode\";\nimport { globalObject, passiveSupported } from \"../global\";\nimport { isGProxy, ISPROXY, PROXYTARGET, unGProxy } from \"../GProxy\";\n\nexport default {\n    'GTpl': GTpl,\n    'GGenerator': GGenerator,\n    'GAddToo': GAddToo,\n    'jit': {\n        'GCompile': GCompile,\n        'GCode': GCode\n    },\n    'utils': {\n        'stack': STACK,\n        'css2obj': css2obj,\n        'style2css': style2css,\n        'globalObject': globalObject,\n        'passiveSupported': passiveSupported,\n        'isGProxy': isGProxy,\n        'unGProxy': unGProxy,\n        'PROXYTARGET': PROXYTARGET,\n        'ISPROXY': ISPROXY\n    }\n};\n"],"names":["root","factory","exports","module","define","amd","this","palabrasReservadas","s","i","l","r","arr_acepted","ln","constructor","setAceptedAN","getResult","getSingleResult","result","length","setString","str","acepted","Array","from","map","c","charCodeAt","checkStart","checkEnd","next","nop","all","cstop","cnow","includes","ok","isAN","firstCanNumber","undefined","n","code","indexOf","getVOrC","ct","getConst","va","getVar","isNumber","temp","num","getNumber","point","split","into","clast","char","hasDecimalPoint","check","obj","vorc","thereare","push","fnc","functions","func","name","params","index","target","join","searchFormula","substring","formula","vars","findVars","codeToParse","trim","originalS","originalI","originalL","freeVars","ignoreStack","addToIgnore","isIgnored","some","ctx","skipWhitespace","test","skipStringLiteral","quote","skipTemplateLiteral","braceCount","exprStart","expr","forEach","token","v","extractToken","tokenStart","tokenObj","j","tryParseArrowParams","startParen","parenCount","ch","paramsStr","substr","param","trimmed","tryParseCatchClause","errorToken","tryParseFunctionDeclaration","maybeName","declares","pop","prevI","declared","globalObject","it","Math","globalThis","window","self","g","Function","ex","ptemp","options","passive","addEventListener","removeEventListener","err","passiveSupported","gparse","gcont","gcontchar","regex_var","getGen","nodeName","atributos","nodelist","getFunction","gen","parent","commongen","com","var","addGen2Obj","bind","uuid","plus","jsonBind","Attributes2JSON","addGen2ObjConditional","bind_for","jsonAttr2","jsonAttr","uid","parseAttribute","prop","value","tt","attrObj","type","link","unshift","match","svar","csstext","cssobj","css2obj","key","val","Object","entries","style2css","startsWith","onlyone","json","attr","isArray","JSON","stringify","subKey","subValue","fncParams","isAsync","fncBody","log","getId","letras","prefijo","floor","obtenerPrefijoChar","String","padStart","async","NodeList2Function","nodes","headers","bindSwitch","GParse","bind_switch","bind_case","bind_if","bind_is","bind_tpl","ele","real","childs","childsnodes","attrs","parse","fin","node","nodeType","toLowerCase","textContent","attributes","ref","item","Error","case","tpl","document","getElementById","content","childNodes","fetch","text","doc","DOMParser","parseFromString","body","common","cases","ccase","normal","nodeValue","html","Node","css","replace","m","toUpperCase","toLocaleLowerCase","typeArray","args","console","arg","shift","stack","ISPROXY","Symbol","PROXYTARGET","proxyCache","WeakMap","handlersMap","fakeEventHandler","isGProxy","GProxy","createGProxy","event","objRef","parentPath","isStaticType","existing","get","add","proxy","handler","targetOriginal","receiver","iterator","origIter","Reflect","set","handlers","deleteProperty","has","ownKeys","getOwnPropertyDescriptor","getProxyHandler","revoke","Proxy","revocable","Set","unGProxy","path","delete","size","entry","globalCache","binitChangeEvents","privateProperties","static","init","gtpl","globalVar","GenerationFinish","MarkEle","memValues","renderElements","getProperty","setProperty","simetricAttr","addCheckRenderElement","re","updateVar","force","reduce","ret","Root","reduceVar","limit","getValue","reduceFnc","initval","getContext","arrval","apply","STACK","calculateBind","me","extraarguments","createGetterAndSetter","BindTree","objdef","pro","BindDef","hasOwnProperty","defineProperty","BoundEventProxy","newval","eventPRoxy","message","addBind2Object","BindMap","Map","tree","getBind2Object","delBind","simetric","setBindings","nuevo","filter","searchBind","encontrado","removeElements","elements","element","destroy","parentNode","removeChild","iterBind","btree","arr","depth","bindValue","subPath","slice","keyAtDepth","nextValue","checkMarkEle","bresult","mark","show","remove","insertBefore","hide","insert","renderBind","render","getElementIndex","canrender","allok","checks","checkMarkRender","RenderElements","Elements","createGTpl","objindex","elementos","row","refresh","generator","context","GTpl","ID","FncElements","BindConst","GtplChilds","Parent","Context","random","toString","loadOptions","GAddToo","getGtplRoot","getRoot","addBind","checkBindVar","preventDefault","stopPropagation","checkBindEvent","checkBindFormula","endsWith","changeEvent","initChangeEvents","prototype","original","call","checkSimetricBind","checkBind","launchChange","child","clear","removeEventHandler","ctxgtpl","eles","addTo","render_arr","pa","updateTEXTbind","updateProperty","removeAttribute","getAttribute","setAttribute","updateATTRbind","innerHTML","updateINNERbind","style","updateSTYLEbind","updateIFbind","delete_arr","isNaN","newgtpl","splice","ppath","update","rowinfo","renderindex","updateFORbind","gtplcase","refCase","mcobj","ca","updateSWITCHbind","updateISbind","originalbind","marca","checkRenderElements","bindNode","appendChildsFromFnc","objRoot","appendChild","createElement","fncChilds","tempvar","createTextNode","createComment","error","GGenerator","GCompile","gcode","ggenerator","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","enumerable","e","toStringTag","GCode"],"sourceRoot":""}